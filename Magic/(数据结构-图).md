[TOC]



# 四、图

## 1、定义

<img src="(数据结构-图).assets/image-20221113144345205.png" alt="image-20221113144345205" style="zoom:67%;" /> 



## 2、类型

### 2.1、有向图/无向图

<img src="(数据结构-图).assets/image-20221113144518419.png" alt="image-20221113144518419" style="zoom:67%;" /> 





### 2.2、简单图/多重图

<img src="(数据结构-图).assets/image-20221113145107821.png" alt="image-20221113145107821" style="zoom:67%;" /> 



## 3、概念

### 3.1、度

<img src="(数据结构-图).assets/image-20221113145509792.png" alt="image-20221113145509792" style="zoom:67%;" /> 



### 3.2、顶点-顶点的关系描述

> 强调几个地方
>
> `简单路径`：指的是顶点不重复出现的路径
>
> `点到点的距离`：从顶点u出发，到顶点v的最短路径的距离，若不存在则为无穷
>
> `强连通`：在有向图中，从u到v的路径存在，从v到u的路径存在

<img src="(数据结构-图).assets/image-20221113145848683.png" alt="image-20221113145848683" style="zoom:67%;" /> 





### 3.3、连通图

> **连通图**：
>
> 对于n个顶点的无向图G，
>
> 若G是连通图，则最少有n-1条边
>
> 这个嘛，就拿树来联想吧，除了根节点，每个结点头上都有一条线
>
> 
>
> 若G是非连通图，则最多可能有<img src="(数据结构-图).assets/image-20221113173947690.png" alt="image-20221113173947690" style="zoom:67%;" />
>
> n-1个结点，任意两两配对所形成的边数，必须除去了一个结点，防止形成连通图
>
> 
>
> **强连通图**：
>
> 若G是强连通图，则最少有n条边
>
> 结合下图理解
>
> <img src="(数据结构-图).assets/image-20221113174443614.png" alt="image-20221113174443614" style="zoom:67%;" /> 
>
> 

<img src="(数据结构-图).assets/image-20221113155354372.png" alt="image-20221113155354372" style="zoom:67%;" /> 





### 3.4、子图

> **生成子图**，包含原图的所有顶点，边集合包含于原边集合

<img src="(数据结构-图).assets/image-20221113155444162.png" alt="image-20221113155444162" style="zoom:67%;" /> 





### 3.5、连通分量/强连通分量

> `无向图`中的`极大连通子图`称为`连通分量`
>
> **极大连通子图**：子图必须连通，且包含尽可能多的顶点和边

<img src="(数据结构-图).assets/image-20221113155750593.png" alt="image-20221113155750593" style="zoom:67%;" /> 



> **强连通分量**

<img src="(数据结构-图).assets/image-20221113160041885.png" alt="image-20221113160041885" style="zoom:67%;" /> 





### 3.6、生成-树/森林

> `连通图`的`生成树`：包含图中`全部顶点`的一个`极小连通子图`(边尽可能地少，但要保持连通)
>
> 若连通图的定点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则不连通；若加上一条边则会形成回路

<img src="(数据结构-图).assets/image-20221113161045815.png" alt="image-20221113161045815" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221113162414247.png" alt="image-20221113162414247" style="zoom:67%;" /> 





### 3.7、带权图

<img src="(数据结构-图).assets/image-20221113162524945.png" alt="image-20221113162524945" style="zoom:67%;" /> 





### 3.8、完全图

<img src="(数据结构-图).assets/image-20221113162637886.png" alt="image-20221113162637886" style="zoom:67%;" /> 







### 3.9、稀疏/稠密图

<img src="(数据结构-图).assets/image-20221113162723665.png" alt="image-20221113162723665" style="zoom:67%;" /> 





### 3.10、树

<img src="(数据结构-图).assets/image-20221113163244544.png" alt="image-20221113163244544" style="zoom:67%;" /> 







### 3.11、总结

![image-20221113163313840]((数据结构-图).assets/image-20221113163313840.png)





## 4、邻接矩阵法

<img src="(数据结构-图).assets/image-20221113163803581.png" alt="image-20221113163803581" style="zoom:67%;" /> 





### 4.1、出入度

![image-20221113164047751]((数据结构-图).assets/image-20221113164047751.png)







### 4.2、带权图

<img src="(数据结构-图).assets/image-20221113164241333.png" alt="image-20221113164241333" style="zoom:67%;" /> 





### 4.3、性能分析

<img src="(数据结构-图).assets/image-20221113164411531.png" alt="image-20221113164411531" style="zoom:67%;" /> 





### 4.4、性质

> A^n的元素A^n[i] [j] = 从顶点i到顶点j的长度为n的路径的数目
>
> 例：A^2[1] [4] = 把原矩阵的第一行 * 第四列，得到的值就是路径数目的个数

<img src="(数据结构-图).assets/image-20221113173443195.png" alt="image-20221113173443195" style="zoom:67%;" /> 



> A^3[1] [4] = 把A^2[1] [4]的第一行 * 原矩阵的第四列，得到的值就是路径数目的个数

<img src="(数据结构-图).assets/image-20221113173659851.png" alt="image-20221113173659851" style="zoom:67%;" /> 







### 4.5、总结

<img src="(数据结构-图).assets/image-20221113173728743.png" alt="image-20221113173728743" style="zoom:67%;" /> 





## 5、邻接表法

> *first指向第一条边，而链表的每一个结构体中间存储了指向的下标

<img src="(数据结构-图).assets/image-20221113175538741.png" alt="image-20221113175538741" style="zoom:67%;" /> 



> 如何求顶点的度？入度？出度？
>
> **无向图**：很简单，遍历得到这个结点的链表长度完事了
>
> 
>
> **有向图**：出度，遍历得到该接点的链表长度；但是入度就很麻烦，你要遍历数组全部元素的链表，求出指向指定结点的结点的个数
>
> 

<img src="(数据结构-图).assets/image-20221113175936914.png" alt="image-20221113175936914" style="zoom:67%;" /> 







## 6、图的基础操作

<img src="(数据结构-图).assets/image-20221113225943233.png" alt="image-20221113225943233" style="zoom:67%;" /> 



### 6.1、BFS(广度优先遍历)

<img src="(数据结构-图).assets/image-20221114003218841.png" alt="image-20221114003218841" style="zoom:67%;" /> 



> 整挺好，但是忽略了非连通图的情况

<img src="(数据结构-图).assets/image-20221114003645702.png" alt="image-20221114003645702" style="zoom:67%;" /> 

> 补充一下`遍历的可变性`
>
> 同一个图的`邻接矩阵`表示方式唯一，所以最后会是一个递增的结果
>
> <img src="(数据结构-图).assets/image-20221114004021715.png" alt="image-20221114004021715" style="zoom:67%;" /> 
>
> 
>
> 同一个图的`邻接表`表示方式不唯一，BFS得到序列不唯一
>
> <img src="(数据结构-图).assets/image-20221114004143911.png" alt="image-20221114004143911" style="zoom: 50%;" /> 
>
> <img src="(数据结构-图).assets/image-20221114003945698.png" alt="image-20221114003945698" style="zoom:67%;" /> 





> 最终代码实现

<img src="(数据结构-图).assets/image-20221114004552753.png" alt="image-20221114004552753" style="zoom:67%;" /> 



> **性能分析**
>
> *空间复杂度*
>
> 可能辅助队列的空间复杂度量级最大为O(|V|)
>
> <img src="(数据结构-图).assets/image-20221114005115123.png" alt="image-20221114005115123" style="zoom: 50%;" /> 
>
> 
>
> *时间复杂度*
>
> 主要来自于访问结点和访问边
>
> 

 











## 逻辑结构の总结

![image-20221113180522651]((数据结构-图).assets/image-20221113180522651.png)

















`

`

`

`

`

`