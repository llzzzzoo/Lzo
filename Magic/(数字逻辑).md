[TOC]



# 一、逻辑代数基础

## 1、电路符号

![在这里插入图片描述]((数字逻辑).assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Nsb3dJc0Zhc3RMZW1vbg==,size_16,color_FFFFFF,t_70.png) 

















# 二、组合逻辑电路

## 1.分析

### 1.1、多数表决器

少数服从多数	

<img src="(数字逻辑).assets/image-20221005200036189.png" alt="image-20221005200036189" style="zoom:50%;" /> 

<img src="(数字逻辑).assets/image-20221005200104529.png" alt="image-20221005200104529" style="zoom:50%;" /> 

<img src="(数字逻辑).assets/image-20221005200013754.png" alt="image-20221005200013754" style="zoom:50%;" /> 





### 1.2、一位二进数的全加器

<img src="(数字逻辑).assets/image-20221005203024670.png" alt="image-20221005203024670" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221005202930969.png" alt="image-20221005202930969" style="zoom:60%;" /> 按照此规则和下面的真值表不难看出这是个全加器

<img src="(数字逻辑).assets/image-20221005202914138.png" alt="image-20221005202914138" style="zoom:50%;" /> c(i)为低位向本位的进位，S为本位和，C(i+1)为本位的进位



#### 1.2.1、多位二进制数相加

<img src="(数字逻辑).assets/image-20221005203458036.png" alt="image-20221005203458036" style="zoom:67%;" /> 级联







## 2、设计

### 2.1、要求

> 电路级数尽量少，输入到输出经过的时间越少，减少延迟(导线或者器件的延时)
>
> 功耗小，工作时间长，稳定可靠

<img src="(数字逻辑).assets/image-20221005203846426.png" alt="image-20221005203846426" style="zoom:55%;" />  





### 2.2、全减器

<img src="(数字逻辑).assets/image-20221005205132593.png" alt="image-20221005205132593" style="zoom:40%;" /> 

 <img src="(数字逻辑).assets/image-20221005205801073.png" alt="image-20221005205801073" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221005205922353.png" alt="image-20221005205922353" style="zoom: 67%;" /> 





### 2.3、输入8421BCD-输出余3码



<img src="(数字逻辑).assets/image-20221005210949643.png" alt="image-20221005210949643" style="zoom:60%;" /> 

<img src="(数字逻辑).assets/image-20221005211044615.png" alt="image-20221005211044615" style="zoom:45%;" /> <img src="(数字逻辑).assets/image-20221005211505306.png" alt="image-20221005211505306" style="zoom:45%;" /> *(1)真值表/卡诺图*

*(2)卡诺图化简*

<img src="(数字逻辑).assets/image-20221005211645820.png" alt="image-20221005211645820" style="zoom:50%;" /> <img src="(数字逻辑).assets/image-20221005211709324.png" alt="image-20221005211709324" style="zoom:50%;" /><img src="(数字逻辑).assets/image-20221005211724259.png" alt="image-20221005211724259" style="zoom:50%;" /><img src="(数字逻辑).assets/image-20221005211739625.png" alt="image-20221005211739625" style="zoom:50%;" />

*(3)逻辑表达式*

<img src="(数字逻辑).assets/image-20221005211829227.png" alt="image-20221005211829227" style="zoom: 40%;" /> 



### 2.4、两个一位十进制数相加

十进制输入输出，8421BCD表示

> 很神奇，8421BCD做加法进位之后，再加6(0110)，就得到和的8421BCD码了

<img src="(数字逻辑).assets/image-20221005214013917.png" alt="image-20221005214013917" style="zoom: 80%;" /> <img src="(数字逻辑).assets/image-20221005213844863.png" alt="image-20221005213844863" style="position: absolute;left: 100px;top: 100px;zoom:50%;" /> 







### 2.5、编码器

#### 2.5.1、8-3编码器

<img src="(数字逻辑).assets/image-20221005220011236.png" alt="image-20221005220011236" style="zoom: 50%;" /> 

<img src="(数字逻辑).assets/image-20221005220152278.png" alt="image-20221005220152278" style="zoom:50%;" /> 真值表，省略了无效部分



#### 2.5.2、二-十进制编码器

介个就是二进制编码器

<img src="(数字逻辑).assets/image-20221005220418838.png" alt="image-20221005220418838" style="zoom:50%;" /> 



#### 2.5.3、10线-4线编码器

<img src="(数字逻辑).assets/image-20221005220303554.png" alt="image-20221005220303554" style="zoom:50%;" /> 

> 从下面的逻辑表达式可以看出
>
> 当8或9信号亮起来的时候，D才会为1，CBA依次类推

<img src="(数字逻辑).assets/image-20221005220800725.png" alt="image-20221005220800725" style="zoom:45%;" /> 



#### 2.5.4、优先级编码器

<img src="(数字逻辑).assets/image-20221005221030171.png" alt="image-20221005221030171" style="zoom:45%;" />  

<img src="(数字逻辑).assets/image-20221005221049748.png" alt="image-20221005221049748" style="zoom:33%;" /> 

> 使能E来了(Enable)
>
> 必须为`低电平才能工作`

<img src="(数字逻辑).assets/image-20221005221353458.png" alt="image-20221005221353458" style="zoom:50%;" /> 

> 教你看表
>
> ​	这个表的`输入下面的7有最高的优先级`
>
> 为什么呢？
>
> ​	你看第三行，**输入7第一个为0，遇到非门为1(有效)，其他的不管取任意的，输出都由输入7决定**
>
> ​	再看第四行，**输入7第一个为1，遇到非门为0(无效)，此时第二个取0(遇到非门为1，有效)，后面的不管取什么，输出都由输入6决定**
>
> ​	......
>
> 即，`当屏蔽了输入7的时候，输入6才能起效果；屏蔽了输入6的时候，输入5才能起效果......`
> 简言之，<u>从7-0的优先级，只要其中一个位置存在，并且它前面的位置不存在，它就是老大，决定最后的输出，介个就是优先级</u>

<img src="(数字逻辑).assets/image-20221005221505564.png" alt="image-20221005221505564" style="zoom:33%;" /> 功能表是也





### 2.6、译码器

Decorder

这里讲的是二进制译码器吧

<img src="(数字逻辑).assets/image-20221006194320867.png" alt="image-20221006194320867" style="zoom: 33%;" />  

<img src="(数字逻辑).assets/image-20221006195552185.png" alt="image-20221006195552185" style="zoom: 33%;" /> 

<img src="(数字逻辑).assets/image-20221006195929830.png" alt="image-20221006195929830" style="zoom:33%;" /> 

<img src="(数字逻辑).assets/image-20221006202529182.png" alt="image-20221006202529182" style="zoom: 33%;" /> 





#### 2.6.1、74LS138(38译码器)

<img src="(数字逻辑).assets/image-20221006200723792.png" alt="image-20221006200723792" style="zoom:50%;" /> 3输入8输出3使能端

> 输出带个圈，如果想本来输出为1的，非成0了；`全输出为1，表明屁输出没有`
>
> `E1使能端也带个圈哦`，be careful

<img src="(数字逻辑).assets/image-20221006200924834.png" alt="image-20221006200924834" style="zoom:40%;" /> 功能表是也

<img src="(数字逻辑).assets/image-20221006201817406.png" alt="image-20221006201817406" style="zoom:50%;" /> 这是低电平输出有效的情况，输出方程：非mi；如果高电平输出有效，输出方程：mi（结合上图想想）

<img src="(数字逻辑).assets/image-20221006201739107.png" alt="image-20221006201739107" style="zoom: 33%;" /> 

<img src="(数字逻辑).assets/image-20221006202427145.png" alt="image-20221006202427145" style="zoom:45%;" /> 看看电路 





#### 2.6.2、地址译码器

> `实际上同一时刻只能有一个硬件起作用`
>
> 我们之所以感觉是在同时工作是因为它们是`交替进行`的
>
> ​	那么，为什么不能同时起作用呢？
>
> ​	看下图，假设数据总线上有一批全0，要送到打印机去，但是扫描仪却把全1送到了数据总线去，发生了`01冲突`，0代表了地面，1代表了电源(电工电路dd)，实际上就是将电源与地面连起来(放一起)，暂且理解为电源自导，瞬间发烫寄了

<img src="(数字逻辑).assets/image-20221006203403792.png" alt="image-20221006203403792" style="zoom: 38%;" />  

> `D和其线路为数据总线`
>
> `Decoder为地址译码器`，`A1、A0决定了这次访问那个地址`，好比你输入00，就是访问地址00的register，此时传出去的四个Y会使得其中只有一个register工作，其他罢工，这样就`好像实现了自由选择了某个地址存储D的数据一样`

<img src="(数字逻辑).assets/image-20221006204514700.png" alt="image-20221006204514700" style="zoom:50%;" /> 



> 看下面的电路，为了使其使能端工作，不得不限制A7654的值，这样就好像把它限制在了一个地址的范围内
>
> <img src="(数字逻辑).assets/image-20221006210259117.png" alt="image-20221006210259117" style="zoom:50%;" /> 牛的
>
> <img src="(数字逻辑).assets/image-20221006210850371.png" alt="image-20221006210850371" style="zoom:50%;" /> 正所谓有效地址范围，其实是通过逻辑门限制出来的，神奇



> `译码器扩展`，很强
>
> A2A1A0乒乓式工作，所以统一接相同总线
>
> `A3控制了不同的地址译码器工作`

<img src="(数字逻辑).assets/image-20221006214034498.png" alt="image-20221006214034498" style="zoom:60%;" /> 



#### 2.6.3、实现逻辑函数

> `3-8译码器`

<img src="(数字逻辑).assets/image-20221006215238959.png" alt="image-20221006215238959" style="zoom:33%;" /> *低*电平输出有效的输出方程

> 示例：

<img src="(数字逻辑).assets/image-20221006220409357.png" alt="image-20221006220409357" style="zoom: 60%;" /> 





> `4-16译码器`
>
> 先利用4个2-4译码器
>
> 然后我要怎么它乒乓式工作呢？即访问哪个地址(哪个地址处理数据线路cd)
>
> 答：控制使能端
>
> 我再利用了一个2-4译码器，其中输入端为a、b，ab从00到11(4个状态)，每个状态下，cd也可以从00-11(4 * 4)，这样就实现了4-16

<img src="(数字逻辑).assets/image-20221006221534185.png" alt="image-20221006221534185" style="zoom: 67%;" /> 





> `二-十译码器`
>
> 看看就行了宝

<img src="(数字逻辑).assets/image-20221006221754832.png" alt="image-20221006221754832" style="zoom: 50%;" /> 

<img src="(数字逻辑).assets/image-20221006221823883.png" alt="image-20221006221823883" style="zoom:50%;" /> 



> `显示译码器`
>
> 大概讲一下这玩意，你看A3210分别为输入端，你输入不同的电平，Y的电平也会不同，从而对应的线路发光

<img src="(数字逻辑).assets/image-20221006222042601.png" alt="image-20221006222042601" style="zoom:50%;" /> 







### 2.7、数据选择器

#### 2.7.1、2^n选1

<img src="(数字逻辑).assets/image-20221007144718154.png" alt="image-20221007144718154" style="zoom:67%;" /> 

> 下面的逻辑表达式变化得到一个dm的表达式
>
> 最后可以得出真值表，看出的确是在数据选择

<img src="(数字逻辑).assets/image-20221007145017510.png" alt="image-20221007145017510" style="zoom:67%;" /> 

> 2^n个数据 输出1位 的数据选择器的输出方程

<img src="(数字逻辑).assets/image-20221007150127681.png" alt="image-20221007150127681" style="zoom:67%;" /> 



#### 2.7.2、多路信号分时传送

> 如下

<img src="(数字逻辑).assets/image-20221007150951115.png" alt="image-20221007150951115" style="zoom:80%;" /> 





#### 2.7.3、实现组合逻辑函数

> 下面这个表示其实蛮有意思的
>
> **此处的含义，是指对一个通用的具有l个输入变量的逻辑函数的最小项之和表示，但是可能三个地址输入端(n=3)是ABC，但是逻辑函数(l=2)是AB + 非(AB)**
>
> 因为你的`最小项表达式`其实就是`最小项进行相或`
>
> 但是你把`每个最小项与其输出相与` `再相或`之后是`不影响其真值`的
>
> 因为你`输出为0的`，`跟最小项相与还是为0`，`最终的最小项表达式`中，这些家伙`依旧不会存在`
>
> *于是就可以写成下面那个(1,or0)的写法*

<img src="(数字逻辑).assets/image-20221007155440094.png" alt="image-20221007155440094" style="zoom:67%;" /> 



##### ①l=n 

> l=n的时候，依次把输入变量接到MUX的地址输入端，根据最小项，确定MUX的D的值
>
> `l就是函数的输入变量数，具体来说就是最终的逻辑表达式的变量个数`

<img src="(数字逻辑).assets/image-20221007161450413.png" alt="image-20221007161450413" style="zoom:67%;" /> 

> 当输出为F = AB+非(AB)时
>
> *可以推出来数据输入的高低电平*
>
> PS.下面就是`变量的个数等于地址端的个数`

<img src="(数字逻辑).assets/image-20221007162152870.png" alt="image-20221007162152870" style="zoom:67%;" /> 



##### ②l<n

> 当l<n的时候，令其高位地址输入端为1/0
>
> 就像下面F=AB+非(AB)，l=2，但是n有3个啊，怎么办呢，我就让A2为0/1，这样就废弃了四个输入的d(无所谓1/0)，剩下的就如同上面一样了

<img src="(数字逻辑).assets/image-20221007165009551.png" alt="image-20221007165009551" style="zoom:80%;" /> 

<img src="(数字逻辑).assets/image-20221007164910461.png" alt="image-20221007164910461" style="zoom: 67%;" /> 



##### ③l>n

> l>n的时候
>
> 如下`ABC三个输入变量，地址输入端也才两个`
>
> 那就写`只有AB的真值表`，`当AB为00的时候，把它的值带回输出方程，得到了最终的结果为C`
>
> *那么真值表就是输入为00，输出为C咯*
>
> 其它依次类推

<img src="(数字逻辑).assets/image-20221007170013739.png" alt="image-20221007170013739" style="zoom:67%;" /> 

> 下面这道题需要结合上面的图来理解
>
> 首先，我们一眼就看出l>n了
>
> 为什么呢？`因为m可是到了7啊，7的话二进制为111，那么肯定需要三位`，但是我们地址输入端只有两位，怎么办呢？
>
> 结合上面的图，最后经过计算就可以得到`下面F最终的输出方程`
>
> 然后Y与F相互比较就可以得出数据输入的值了
>
> 其实看得出宏观上就是要对Y与F进行比较
>
> 微观上，先求出Y(数据选择器的方程)，再求出F(真实的输出方程)，比较后再得出输入的数据

<img src="(数字逻辑).assets/image-20221007170244043.png" alt="image-20221007170244043" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221007171724302.png" alt="image-20221007171724302" style="zoom:67%;" /> 电路图，余子式，一个变量四个输出



###### 余函数

<img src="(数字逻辑).assets/image-20221007171822558.png" alt="image-20221007171822558" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221007180552764.png" alt="image-20221007180552764" style="zoom: 67%;" /> 



###### 降维卡诺图

<img src="(数字逻辑).assets/image-20221007180631327.png" alt="image-20221007180631327" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221007181145240.png" alt="image-20221007181145240" style="zoom: 50%;" /> 

<img src="(数字逻辑).assets/image-20221007195452522.png" alt="image-20221007195452522" style="zoom:50%;" /> 





> 例题
>
> <img src="(数字逻辑).assets/image-20221007195857933.png" alt="image-20221007195857933" style="zoom:50%;" /> 
>
> <img src="(数字逻辑).assets/image-20221007195919605.png" alt="image-20221007195919605" style="zoom:50%;" /> 
>
> <img src="(数字逻辑).assets/image-20221007195940521.png" alt="image-20221007195940521" style="zoom:50%;" /> 
>
> 



###### 数据选择器的扩展

> 8个数据输入端，2个使能端，通过A2控制其乒乓式工作

<img src="(数字逻辑).assets/image-20221007200126214.png" alt="image-20221007200126214" style="zoom: 67%;" /> 

> 尽管四个Y都输出，但是A3A2控制开关只能打到其中一个，即只有一组4d会被选择
>
> 然后4d再搞一个4选1
>
> 最终实现16选1

<img src="(数字逻辑).assets/image-20221007200917293.png" alt="image-20221007200917293" style="zoom:50%;" /> 

<img src="(数字逻辑).assets/image-20221007200556378.png" alt="image-20221007200556378" style="zoom:67%;" /><img src="(数字逻辑).assets/image-20221007201302174.png" alt="image-20221007201302174" style="zoom: 67%;" />  

> 下面有一个其他的16-1的电路
>
> 总之反正大概理解一下意思就行了
>
> 先利用2-4地址译码器，选择一个4选1数据选择器正常工作，然后再经过4选1得到那一个信号
>
> 由于其他3个4-1输出无效，输出无效的时候输出为0，所以利用或门留下选出的那个信号
>
> (ps.你要想想数据是持续输入的，假设持续输入1010111...而无效的输出000000...因为哪一个d都没有选择，所以输出为0咯，最后利用或门留下有效的d
>
> 而且此处恰好无效的0不影响有效的0，因为是或门嘛，这里也是一种智慧啊)

<img src="(数字逻辑).assets/image-20221007201340996.png" alt="image-20221007201340996" style="zoom:67%;" /> 





#### 2.7.4、数据传输并串转换

应用：数据从U盘经过USB口传输到电脑就需要串并转换，USB接口为串型的，数据在U盘是并型的，数据传输的时候就需要串并转换

其实你可以这样理解，`数据是并行输入的，但你数据选择之后只能有一个输出，你轮流切换开关，就好像让一行并列的数据呈串型输出了`





#### 2.7.5、产生序列

> 要产生下面的序列

<img src="(数字逻辑).assets/image-20221007154838743.png" alt="image-20221007154838743" style="zoom: 67%;" /> 

<img src="(数字逻辑).assets/image-20221007154938230.png" alt="image-20221007154938230" style="zoom: 67%;" /> 只需要循环的从d0到d7切开关就完事了









### 2.8、数据分配器

<img src="(数字逻辑).assets/image-20221008204516250.png" alt="image-20221008204516250" style="zoom:67%;" /> 

> 这里利用**译码器**来实现数据分配，一般不会这么用
>
> 原理：把`数据输入端`和`使能端`放到一起
>
> **当D=0的时候**，器件工作，此时AB地址端选择一个输出端有效，众所周知，`低电平输出有效`，所以选择的有效输出端`此时输出为0`
>
> 是不是就`相当于`把`等于0的D`，`分配`到了`输出为0指定的位置输出` ——> 好好感受，等价的喵用，我分配但不是真的把它运过去，搞一个*替身*，好像我分配过去了
>
> **当D=1的时候**，器件罢工，`任意输出端都为1`，那你地址端`任意选个地址`，是不是都是`输出为1`，也相当于把1分配过去

<img src="(数字逻辑).assets/image-20221008204721084.png" alt="image-20221008204721084" style="zoom:67%;" /> 









### 2.9、竞争与冒险

<img src="(数字逻辑).assets/image-20221008205928598.png" alt="image-20221008205928598" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221008210427089.png" alt="image-20221008210427089" style="zoom:67%;" /> 

> **竞争与冒险的识别**
>
> 不是说电路最简最好，具体原因见下

<img src="(数字逻辑).assets/image-20221008211419855.png" alt="image-20221008211419855" style="zoom:67%;" /> 

> 我的理解：这个滤波电容C的作用，*当你信号突变为0，即电平降低，电流减小，发生陡变*，`但是电容给你充电，然后整体电路的变化就没那么陡`；*当信号突变为1，电流增大，发生陡变*，`电容给你挡着的(或者说先吸收电流？)，整体电路变化就不会那么陡`

<img src="(数字逻辑).assets/image-20221008211941634.png" alt="image-20221008211941634" style="zoom:67%;" /> 













# 三、时序逻辑电路



## 1、触发器

> p和Q互斥
>
> Q为主状态

<img src="(数字逻辑).assets/image-20221008221256060.png" alt="image-20221008221256060" style="zoom:67%;" />  <img src="(数字逻辑).assets/image-20221008221733787.png" alt="image-20221008221733787" style="zoom:67%;" />Q为主状态，所以置数、复位、保持都是对它来说

> 由于P与Q相反，所以P可以写为非Q，从而利用三个逻辑变量表是PQ

<img src="(数字逻辑).assets/image-20221009192717373.png" alt="image-20221009192717373" style="zoom:67%;" /> 

<img src="(数字逻辑).assets/image-20221009192643815.png" alt="image-20221009192643815" style="zoom:67%;" /> 



### 1.1、状态转移真值表(Truth Table)

简称状态表

<img src="(数字逻辑).assets/image-20221009193528784.png" alt="image-20221009193528784" style="zoom: 80%;" /> 

<img src="(数字逻辑).assets/image-20221009193933247.png" alt="image-20221009193933247" style="zoom:67%;" /> 11保持/00达咩



### 1.2、状态方程(转移方程)

就是逻辑表达式





### 1.3、状态转移图(激励表)

> 下一个状态与前一个状态有关，图像表现就是从上一个状态加上本次的输入输出才等于本次的状态

<img src="(数字逻辑).assets/image-20221009194753729.png" alt="image-20221009194753729" style="zoom:67%;" /> 



> **激励表**
>
> 与其他表不同的是，`它是知道输出，求输入`；别的表是知道输入，求输出

<img src="(数字逻辑).assets/image-20221009195209846.png" alt="image-20221009195209846" style="zoom:67%;" /> 







### 1.4、波形图(时序波形)

> 有两个点
>
> 第一，当R、S同时为0时，`尽管不合理，但是输出仍存在`，带入电路发现全为1
>
> 第二，不确定状态，这玩意出现在`不合理状态+保持当前状态`的时候

<img src="(数字逻辑).assets/image-20221009200349022.png" alt="image-20221009200349022" style="zoom:67%;" /> 



> 下面解释了*为什么是波形图是不确定*

<img src="(数字逻辑).assets/image-20221009200105127.png" alt="image-20221009200105127" style="zoom: 80%;" /> 







### 1.5、时钟控制的触发器

#### 1.5.1、钟控RS触发器

说变了就是CP(clockpulse:时钟脉冲)控制的触发器

<img src="(数字逻辑).assets/image-20221011230022848.png" alt="image-20221011230022848" style="zoom:60%;" /> 

> 下面就是`钟控RS触发器`的电路图
>
> 为什么要搞这玩意呢？
>
> 这玩意的`工作节拍无法控制`，说人话就是你不能控制它工作或者不工作
>
> but，*我给它输入它就工作，不给它输入它就不工作*，**的确可以**
>
> however，你的输入受到了干扰怎么办(好比虽然你没输入了，天边突然来了道闪电，给了你满满的输入bushi)。这时候就需要其他法子来控制它的工作节拍了。
>
> 

> 带你研究一下这玩意
>
> `利用CP可以控制触发器的工作节拍`
>
> 具体原理：
>
> 当CP为1的时候，最终与非的结果(D)取决于输入的R、S
>
> 当CP为0的时候，最终D总是为1，相当于RD和SD全为1，即为保持状态
>
> 当我想让它工作的时候CP就输入1，不想让它工作的时候CP输入0，`哪怕外部莫名其妙的出现了一些输入，也能让其保持当前的状态`
>
> <img src="(数字逻辑).assets/image-20221012165541373.png" alt="image-20221012165541373" style="zoom: 50%;" /> 



<img src="(数字逻辑).assets/image-20221012165328897.png" alt="image-20221012165328897" style="zoom:60%;" /> 

<img src="(数字逻辑).assets/image-20221012171337972.png" alt="image-20221012171337972" style="zoom:60%;" />  





#### 1.5.2、钟控D触发器

> 钟控RS触发器虽然很cool，但是有约束条件还是不够酷，为了让它无拘无束，钟控D触发器来了
>
> Delay

<img src="(数字逻辑).assets/image-20221012172750851.png" alt="image-20221012172750851" style="zoom:67%;" /> 电路图

> 观察上面的输入，不难发现，当CP为1的时候，SD取反才得到RD，所以此处解决了约束问题
>
> 再经过下面的推导，可以得出特征方程：Q(n+1)=D
>
> <img src="(数字逻辑).assets/image-20221012172427306.png" alt="image-20221012172427306" style="zoom:67%;" /> 
>
> <img src="(数字逻辑).assets/image-20221012172704227.png" alt="image-20221012172704227" style="zoom:67%;" /> 







#### 1.5.3、钟控T触发器

> 另一个解决约束条件问题的触发器——> `钟控T触发器`
>
> Toggle

<img src="(数字逻辑).assets/image-20221012174843400.png" alt="image-20221012174843400" style="zoom:67%;" /> 

> 通过电路得出R、S和T、Q的关系
>
> 最后将R、S带入钟控RS触发器的特征方程，发现
>
> 特征方程：Q(n+1) = T 异或 Q
>
> <img src="(数字逻辑).assets/image-20221012174349852.png" alt="image-20221012174349852" style="zoom:67%;" /> <img src="(数字逻辑).assets/image-20221012174514271.png" alt="image-20221012174514271" style="zoom:67%;" />
>
> <img src="(数字逻辑).assets/image-20221012175958455.png" alt="image-20221012175958455" style="zoom: 50%;" /> 状态图，很细的
>
> 











#### 1.5.4、钟控JK触发器

> 差不多 把T分成了JK
>
> 而且它综合了前面几个触发器的功能
>
> J K：0 0  ——> 保持
>
> J K：0 1  ——> 复位
>
> J K：1 0  ——> 置位
>
> J K：1 1  ——> 翻转

<img src="(数字逻辑).assets/image-20221012175635356.png" alt="image-20221012175635356" style="zoom:67%;" /> 

> 仍然解决了约束问题
>
> <img src="(数字逻辑).assets/image-20221012175549052.png" alt="image-20221012175549052" style="zoom:67%;" /> 特征方程	其实J = K = T，你带进去依然是T异或Q
>
> 
>
> <img src="(数字逻辑).assets/image-20221012182855350.png" alt="image-20221012182855350" style="zoom:60%;" />  

 



#### 1.5.5、边沿触发方式触发器

> 1、CP某一约定跳变什么意思？
>
> ​	即这哥们突然翻转了，才接受输入信号
>
> 2、空翻现象？
>
> ​	即误翻转，本来知道了输入信号，通过特征方程就可以得出输出，但是最后的输出可能超出预期

<img src="(数字逻辑).assets/image-20221012215740098.png" alt="image-20221012215740098" style="zoom: 50%;" /> 









### 1.6、触发器的逻辑符号及时序图

#### 1.6.1、逻辑符号

<img src="(数字逻辑).assets/image-20221013213445143.png" alt="image-20221013213445143" style="zoom: 50%;" /> 

<img src="(数字逻辑).assets/image-20221013213737814.png" alt="image-20221013213737814" style="zoom:67%;" /> 



#### 1.6.2、异步信号

> 同步信号受到时钟的控制
>
> 异步信号不管时钟，强制输入

<img src="(数字逻辑).assets/image-20221013214458405.png" alt="image-20221013214458405" style="zoom:67%;" /> 







#### 1.6.3、时序图

2分频

出现条件就是Q(n+1) = 非Q(n)

> 根据CP和输入，得出特征方程和边沿触发的条件。就可以画出时序图了
>
> ​													下面粉色的线就是输出发生变化的条件

<img src="(数字逻辑).assets/image-20221013215655638.png" alt="image-20221013215655638" style="zoom:67%;" /> <img src="(数字逻辑).assets/image-20221013215425448.png" alt="image-20221013215425448" style="zoom:67%;" />  

> 示例：
>
> 仔细看，这张图叫做时序图
>
> 钟控D触发器的`主输出状态q应该等于D`
>
> 但是看下图，其实是不相等的，因为这是边沿触发器
>
> 即`在处于上边沿或者下边沿`的时候，`接受一次输入`，然后`保持此状态直到下个边沿情况`
>
> <img src="(数字逻辑).assets/image-20221013220028772.png" alt="image-20221013220028772" style="zoom:60%;" />  





![image-20221017203437609]((数字逻辑).assets/image-20221017203437609.png)



​	











## 2、时序电路的分析与设计

<img src="(数字逻辑).assets/image-20221017213656169.png" alt="image-20221017213656169" style="zoom: 50%;" /> 





### 2.1、时序逻辑电路的特点及分类

#### 2.1.1、特点

> 不管时序电路多么复杂，最后都能找到
>
> 三个方程，输出方程，激励方程，状态方程

<img src="(数字逻辑).assets/image-20221020212813642.png" alt="image-20221020212813642" style="zoom: 50%;" />  时序逻辑就是组合逻辑和存储电路的结合

<img src="(数字逻辑).assets/image-20221020212948352.png" alt="image-20221020212948352" style="zoom: 33%;" /> 

<img src="(数字逻辑).assets/image-20221020212848239.png" alt="image-20221020212848239" style="zoom: 50%;" />  





#### 2.1.2、分类

<img src="(数字逻辑).assets/image-20221020213620334.png" alt="image-20221020213620334" style="zoom: 33%;" /> 

<img src="(数字逻辑).assets/image-20221020213633311.png" alt="image-20221020213633311" style="zoom: 33%;" /> 



#### ①Mealy型/Moore型时序电路

<img src="(数字逻辑).assets/image-20221020214915639.png" alt="image-20221020214915639" style="zoom: 67%;" /> 

> Mealy型
>
> 逻辑表达式能显式地看到外部输入(X)

<img src="(数字逻辑).assets/image-20221024211201800.png" alt="image-20221024211201800" style="zoom:60%;" />  

> MORE型
>
> 只包含状态，不包含外部输入

<img src="(数字逻辑).assets/image-20221024211339272.png" alt="image-20221024211339272" style="zoom:60%;" /> 







#### ②对应状态真值表

Mealy型

<img src="(数字逻辑).assets/image-20221024212951280.png" alt="image-20221024212951280" style="zoom: 43%;" /> 

Moore型

<img src="(数字逻辑).assets/image-20221024213017231.png" alt="image-20221024213017231" style="zoom:43%;" /> 















`

`

`

`

`

`

`
