[TOC]





# 一、指令格式

## 1、定义

<img src="(计算机组成原理-指令系统).assets/image-20221206131202818.png" alt="image-20221206131202818" style="zoom:67%;" /> 





## 2、不同的地址码数目

<img src="(计算机组成原理-指令系统).assets/image-20221206131330387.png" alt="image-20221206131330387" style="zoom:67%;" /> 



### 2.1、零地址指令

操作数就是操作对象

<img src="(计算机组成原理-指令系统).assets/image-20221206131710083.png" alt="image-20221206131710083" style="zoom:67%;" /> 





### 2.2、一地址指令

<img src="(计算机组成原理-指令系统).assets/image-20221206132326274.png" alt="image-20221206132326274" style="zoom:67%;" /> 



### 2.2、二三地址指令

<img src="(计算机组成原理-指令系统).assets/image-20221206173759006.png" alt="image-20221206173759006" style="zoom:67%;" /> 



### 2.3、四地址指令

![image-20221206174220332]((计算机组成原理-指令系统).assets/image-20221206174220332.png)



## 3、指令的分类

### 3.1、按指令长度分类

<img src="(计算机组成原理-指令系统).assets/image-20221206174900274.png" alt="image-20221206174900274" style="zoom:67%;" /> 



### 3.2、按操作码分类

![image-20221206175134313]((计算机组成原理-指令系统).assets/image-20221206175134313.png)



### 3.3、按操作类型分类

![image-20221206175609473]((计算机组成原理-指令系统).assets/image-20221206175609473.png)



## 总结

![image-20221206175715100]((计算机组成原理-指令系统).assets/image-20221206175715100.png)











# 二、拓展操作码指令格式

<img src="(计算机组成原理-指令系统).assets/image-20221206175947017.png" alt="image-20221206175947017" style="zoom:67%;" /> 



## 1、扩展操作码

`当识别到前4位是1111的时候就说明它是大于4位的操作码，相应的也不是三地址指令`

主要思想：上层留出一种状态，用以取分上下两层

<img src="(计算机组成原理-指令系统).assets/image-20221206180900463.png" alt="image-20221206180900463" style="zoom:67%;" /> 

> 还可以这么扩展，对于使用频率较高的指令，分配较短的操作码；将较长的操作码分配给使用频率较低的指令

<img src="(计算机组成原理-指令系统).assets/image-20221206181328402.png" alt="image-20221206181328402" style="zoom:67%;" /> 

![image-20221206182318107]((计算机组成原理-指令系统).assets/image-20221206182318107.png)



## 总结

![image-20221206184005844]((计算机组成原理-指令系统).assets/image-20221206184005844.png)







# 三、指令寻址



<img src="(计算机组成原理-指令系统).assets/image-20221208001053509.png" alt="image-20221208001053509" style="zoom:67%;" /> 



## 1、顺序寻址

> 已知 指令字长 = 存储字长 = 16bit = 2B
>
> (1)当系统采用`定长指令字结构`
>
> 主存按字编址：因为一个字为16bit刚好等于一条指令，直接让PC+1就来到下一条指令了
>
> 主存按字节编址：由于一条指令由16bit，于是一条指令占两个地址，即0、1是第一条指令，2、3是第二条指令...
>
> ​             —— 具体指令地址体现为0、2、4、6...
>
> ​			 于是可以让PC + 2来移动，2为一条指令所占的地址数目
>
> (2)当系统采用`变长指令字结构`
>
> 主存按字节编址：指令所占的地址不同
>
> ​             于是可以在读入一个字的时候，根据操作码判断这条指令所占的总字节数n
>
> ​             PC + n，n即为读取到这条指令所占有的地址数	

<img src="(计算机组成原理-指令系统).assets/image-20221208002139440.png" alt="image-20221208002139440" style="zoom:67%;" />  

<img src="(计算机组成原理-指令系统).assets/image-20221208002221009.png" alt="image-20221208002221009" style="zoom:67%;" /> 

<img src="(计算机组成原理-指令系统).assets/image-20221208002419001.png" alt="image-20221208002419001" style="zoom:67%;" /> 







## 2、跳跃寻址

> `跳跃寻址`：当程序读取到转移指令时，会无条件跳转到指定的地址
>
> ​          这里单独提一下就是因为，`本来PC遇到跳跃指令的时候是先到它的下一位欲执行的地址的`，但是跳跃指令就会强行扭转它到达的位置

<img src="(计算机组成原理-指令系统).assets/image-20221208003514460.png" alt="image-20221208003514460" style="zoom:67%;" /> 





## 总结

> 值得注意的是PC指向的是下一条欲执行的地址，所以，执行PC指向的某条指令的时候是`先让PC移动，再执行操作码内容`

<img src="(计算机组成原理-指令系统).assets/image-20221208003602524.png" alt="image-20221208003602524" style="zoom:67%;" /> 







# 四、数据寻址

<img src="(计算机组成原理-指令系统).assets/image-20221209013355713.png" alt="image-20221209013355713" style="zoom:67%;" /> 



## 1、直接寻址

<img src="(计算机组成原理-指令系统).assets/image-20221209014029673.png" alt="image-20221209014029673" style="zoom:67%;" /> 



## 2、间接寻址

> 优点就是`扩大了寻址范围`，因为下面EA = (A)的时候，你可以让存储字长的32bit全为地址指令啊，这样的范围就到0~2^(32)了

<img src="(计算机组成原理-指令系统).assets/image-20221209014601093.png" alt="image-20221209014601093" style="zoom:67%;" /> 





## 3、寄存器寻址

> 就是把寄存器利用起来，让指令指向的地址表示寄存器的地址，寄存器嘛，访问速度快，而且个数不多，所以指令也不需要多长，节约空间嘛

<img src="(计算机组成原理-指令系统).assets/image-20221209015108866.png" alt="image-20221209015108866" style="zoom:67%;" /> 





## 4、寄存器间接寻址

> 指令指向寄存器，但是寄存器的data域是主存所在单元的地址，就访问速度快一点咯

<img src="(计算机组成原理-指令系统).assets/image-20221209015327651.png" alt="image-20221209015327651" style="zoom:67%;" /> 





## 5、隐含寻址

> 没有明显的给出操作数的地址，就像前面的一地址指令的两个操作数，一个操作数隐含在寄存器(如ACC)里面

<img src="(计算机组成原理-指令系统).assets/image-20221209015518670.png" alt="image-20221209015518670" style="zoom:67%;" /> 





## 6、立即寻址

> 指令就是操作数，一般操作数是补码的形式

<img src="(计算机组成原理-指令系统).assets/image-20221209015819692.png" alt="image-20221209015819692" style="zoom:67%;" /> 



## 总结

<img src="(计算机组成原理-指令系统).assets/image-20221209015903335.png" alt="image-20221209015903335" style="zoom:67%;" /> 



## 7、偏移寻址

<img src="(计算机组成原理-指令系统).assets/image-20221210131334558.png" alt="image-20221210131334558" style="zoom:67%;" /> 

### 7.1、基址寻址

> `基址寻址`：将CPU中基址寄存器(BR: base address register)的内容加上指令格式中的形式地址A，而形成操作数的有效地址
>
> ​		 即EA = (BR) + A（利用ALU进行加法）
>
> 对于基址寄存器，有两种选择
>
> (a)采用专门的寄存器作为BR
>
> (b)采用通用寄存器作为基址寄存器，区别在于，需要在`指令中声明哪个通用寄存器作为基址寄存器使用`

<img src="(计算机组成原理-指令系统).assets/image-20221210131732371.png" alt="image-20221210131732371" style="zoom:67%;" /> 

> 优点有两个
>
> (1)便于“程序”浮动，即程序不必在主存中固定的位置，我可以任意走，只要调整一下(BR)的值就完事了
>
> (2)`多道程序设计`：面前有多个独立的程序，我可以不断的修改(BR)的值，来看似并发，实则串行的执行不同的程序

![image-20221210132245700]((计算机组成原理-指令系统).assets/image-20221210132245700.png)



> BR是面向操作系统的，内容也只有操作系统或者管理程序决定
>
> 如果你是汇编大佬的话，当我没说，*但即便强如汇编，当你决定了某个通用寄存器为基址寄存器的时候，内容也不能由你决定*
>
> 优点除了上面的两个，还有个：`扩大寻址范围`，因为(BR)的位数大于形式地址A的位数啊，所以基址可以很大

<img src="(计算机组成原理-指令系统).assets/image-20221210132746258.png" alt="image-20221210132746258" style="zoom:67%;" /> 





### 7.2、变址寻址

> *为什么可由用户改变*？
>
> 用户进行一些操作之后，变址寄存器的内容会发生改变，相当于由用户改变

<img src="(计算机组成原理-指令系统).assets/image-20221211003303546.png" alt="image-20221211003303546" style="zoom:67%;" /> 	 

> 此处体现出变址寻址的优势了
>
> 
>
> 这是普通寻址，形式地址要不断的改变，依次来访问到后面的内容，因此也需要更多的内存存指令。
>
> <img src="(计算机组成原理-指令系统).assets/image-20221211003133646.png" alt="image-20221211003133646" style="zoom:60%;" /> 
>
> 
>
> 而变址寻址改变的是寄存器的内容，你给两行指令让它加加，配合好形式地址，它就可以依次访问后面的指令了
>
> <img src="(计算机组成原理-指令系统).assets/image-20221211022114764.png" alt="image-20221211022114764" style="zoom:67%;" /> 
>
> 

<img src="(计算机组成原理-指令系统).assets/image-20221211002921748.png" alt="image-20221211002921748" style="zoom:67%;" /> 



### 7.3、基址&变址寻址

> 说白了就是`先把形式地址加上(BR)，再加上(IX)`

<img src="(计算机组成原理-指令系统).assets/image-20221211021528882.png" alt="image-20221211021528882" style="zoom:67%;" /> 







### 7.4、相对寻址

> 简单理解，就是让(PC)+A
>
> 但**注意**：`PC要先+“1”，再加上A`，记得前面说的吗，PC先将值取出来，然后立即+”1“，
>
> ​	   也就是当PC执行内存地址1000的指令时，先把A放入ALU中，然后立即+”1“，这里的加1是加1条指令，可能两个存储字长，可能4个
>
> ​	   总之，`A不是当前指令地址的偏移量，因为还有个PC+“1”在呢`

<img src="(计算机组成原理-指令系统).assets/image-20221211023131212.png" alt="image-20221211023131212" style="zoom:67%;" /> 

<img src="(计算机组成原理-指令系统).assets/image-20221211023642010.png" alt="image-20221211023642010" style="zoom:67%;" /> 

> 真正形成了浑然天成、自成一体
>
> 由于偏移量(补码)可以为负数，于是PC可以往回走，那么你不就可以写循环了吗，执行到最后一行，又回到第一行
>
> 而且是相对最后一行的内存地址来说(当然忘不了PC+“1”)，根本就不用管在哪个程序段

<img src="(计算机组成原理-指令系统).assets/image-20221211023505852.png" alt="image-20221211023505852" style="zoom:67%;" /> 





## 总结

<img src="(计算机组成原理-指令系统).assets/image-20221211024547532.png" alt="image-20221211024547532" style="zoom:67%;" /> 主存中，程序段和数据段会分开

<img src="(计算机组成原理-指令系统).assets/image-20221211023721939.png" alt="image-20221211023721939" style="zoom:67%;" /> 

**硬件实现比较的一些补充**

<img src="(计算机组成原理-指令系统).assets/image-20221211025331301.png" alt="image-20221211025331301" style="zoom:67%;" />  











## 9、堆栈寻址

> 软堆栈：主存中选一块存储区出来，并且按照“后进后出(LIFO)”的原则
>
> 硬堆栈：选用专门的寄存器组

<img src="(计算机组成原理-指令系统).assets/image-20221216125927473.png" alt="image-20221216125927473" style="zoom:67%;" /> 

<img src="(计算机组成原理-指令系统).assets/image-20221216130051572.png" alt="image-20221216130051572" style="zoom:67%;" /> 







# 五、高级语言与机器语言的对应

<img src="(计算机组成原理-指令系统).assets/image-20221218012705289.png" alt="image-20221218012705289" style="zoom:67%;" /> 



## 1、x86汇编语言指令基础

<img src="(计算机组成原理-指令系统).assets/image-20221218015626495.png" alt="image-20221218015626495" style="zoom:67%;" />  

<img src="(计算机组成原理-指令系统).assets/image-20221218013353090.png" alt="image-20221218013353090" style="zoom:67%;" /> 



## 2、寄存器种类

> x86架构下的CPU嗷
>
> E = Extended = 32bit （通用寄存器的32bit）

<img src="(计算机组成原理-指令系统).assets/image-20221218013954516.png" alt="image-20221218013954516" style="zoom:67%;" /> 



> 通用寄存器还可以再分出一般的数据，即16bit来处理数据
>
> 16bit又可以再分为两个8bit，起个别名就可以分别调用空间啦

<img src="(计算机组成原理-指令系统).assets/image-20221218014320485.png" alt="image-20221218014320485" style="zoom:67%;" /> 



> 有几个细节
>
> (1)dword ptr [ebx]，其中ebx是寄存器，[ebx]即为寄存器寻址
>
> (2)[ebx]，这种就是默认的32bit，即dword ptr [ebx]
>
> (3)dword ptr [ebx+8]，指的是把`ebx存放的地址拿出来再+8`

<img src="(计算机组成原理-指令系统).assets/image-20221218015455321.png" alt="image-20221218015455321" style="zoom:67%;" /> 



## 3、常用的x86汇编指令

### 3.1、算术运算

> 注意三个点
>
> (1)`目的操作数d不可以为常量`，因为要把数据存回d(destination)里面
>
> (2)指令里面如imul,idiv，是表明`操作数是有符号数`
>
> (3)关于除法idiv，为什么要配两个寄存器，具体底层是这样的
>
> ​	div s，s作为除数。在发生除法之前，需要把被除数位扩展，变为64位的被除数(刚好两个寄存器edx:eax)，高位放在edx，低位放在eax，发生除法后商放在dax，余数放在edx中

<img src="(计算机组成原理-指令系统).assets/image-20221218025444100.png" alt="image-20221218025444100" style="zoom:67%;" /> 



### 3.2、逻辑运算

<img src="(计算机组成原理-指令系统).assets/image-20221218025949829.png" alt="image-20221218025949829" style="zoom:67%;" /> 



### 3.3、其他指令

<img src="(计算机组成原理-指令系统).assets/image-20221218025921019.png" alt="image-20221218025921019" style="zoom:67%;" /> 	





## 4、AT&T格式 VS Intel格式

<img src="(计算机组成原理-指令系统).assets/image-20221218213018162.png" alt="image-20221218213018162" style="zoom:67%;" /> 



> 解释一下下面的语句
>
> <img src="(计算机组成原理-指令系统).assets/image-20221218213513995.png" alt="image-20221218213513995" style="zoom:67%;" /> 
>
> | mov eax,[ebx + ecx*32 + 4]
>
> 这是：[基址 + 变址*比例因子 + 偏移量]
>
> 使用示例：
>
> ​	当我想访问struct student结构体数组的 单个结构体的 某个成员变量
>
> ​	我就在数组基址(ebx) + 变址(ecx)*单个结构体的大小(32bit) + 偏移量(4，结构体中的位置，见下图)
>
> <img src="(计算机组成原理-指令系统).assets/image-20221218213849435.png" alt="image-20221218213849435" style="zoom:67%;" /> 
>
> 

 



## 5、选择(if)语句的机器级表示

<img src="(计算机组成原理-指令系统).assets/image-20221218214317845.png" alt="image-20221218214317845" style="zoom:67%;" /> 



<img src="(计算机组成原理-指令系统).assets/image-20221218214848750.png" alt="image-20221218214848750" style="zoom:67%;" /> 



> **出现原因**？
>
> jmp 116的话不够兼容啊，玩意大伙地址都改了呢？万一现在要jmp 216怎么办
>
> 所以出现了一个“标号”，通常写为NEXT，但是你可以随意命名。。吧
>
> 使用举例：
>
> ​	jmp NEXT  ---------> 跳转到NEXT地址后面的地址
>
> ​	...
>
> ​	NEXT:     ----------> 记得加冒号
>
> ​	move ecx,eax	------> jump过来执行这条指令

<img src="(计算机组成原理-指令系统).assets/image-20221218215120684.png" alt="image-20221218215120684" style="zoom:67%;" /> 



> 三个点
>
> (1)注意这几个条件转移指令，都要配合，cmp使用嗷
>
> (2) cmp a,b 的两个数可以来自寄存器/主存/常量
>
> (3)稍微记一下这几个小指令

<img src="(计算机组成原理-指令系统).assets/image-20221218215907123.png" alt="image-20221218215907123" style="zoom:67%;" /> 



> `cmp底层比较原理`
>
> cmp a,b就是把a,b在`ALU里面做了个减法`，然后生成了几个`标志位`，并将其`存入PSW(程序状态寄存器)`
>
> 然后`条件转义符`，就去寄存器里面看一下`对应的标志位是否符合条件`，决定是否跳转

<img src="(计算机组成原理-指令系统).assets/image-20221218222137563.png" alt="image-20221218222137563" style="zoom:67%;" /> 





## 6、循环语句(for)的语句表示

### 6.1、条件转移指令实现

<img src="(计算机组成原理-指令系统).assets/image-20221218222753962.png" alt="image-20221218222753962" style="zoom:67%;" /> 

> 结构层次分析

<img src="(计算机组成原理-指令系统).assets/image-20221218222859190.png" alt="image-20221218222859190" style="zoom:67%;" /> 



### 6.2、loop指令实现

> **使用示例**：
>
> Looptop:
>
> ...
>
> loop Looptop	#ecx--,若ecx!=0，跳转到Looptop
>
> ​	loop就相当于 dex ecx ; cmp exc,0 jne Looptop
>
> **注意点**：
>
> (1)`loop只能对ecx寄存器进行--`，所以当你需要使用loop指令时，请把数值放到ecx去
>
> (2)还有其它loop指令，ZF(Zero Flag)零标志，为0时置1，否则置0
>
> <img src="(计算机组成原理-指令系统).assets/image-20221218223639927.png" alt="image-20221218223639927" style="zoom:67%;" /> 

<img src="(计算机组成原理-指令系统).assets/image-20221218223319239.png" alt="image-20221218223319239" style="zoom:67%;" /> 





## 7、CISC和RISC

<img src="(计算机组成原理-指令系统).assets/image-20221218224402078.png" alt="image-20221218224402078" style="zoom:67%;" /> 



> **解释两个点**：
>
> **通用寄存器数量**：CISC较少是因为它可以直接访存，不需要把数据存到寄存器在做运算；RISC更多是因为，它只有Load/Store可以访存，做运算的时候需要先把操作数存到寄存器里面去再做运算
>
> **目标代码**：因为CISC的代码就是一大块拼图，更不能DIY；而RISC底层更小巧，能自己拼拼图，灵活一点

<img src="(计算机组成原理-指令系统).assets/image-20221218224843268.png" alt="image-20221218224843268" style="zoom:67%;" /> 



# I Love You 3 Thousand











`

`

`

`

`

`











