[TOC]



# 四、图

## 1、定义

<img src="(数据结构-图).assets/image-20221113144345205.png" alt="image-20221113144345205" style="zoom:67%;" /> 



## 2、类型

### 2.1、有向图/无向图

<img src="(数据结构-图).assets/image-20221113144518419.png" alt="image-20221113144518419" style="zoom:67%;" /> 





### 2.2、简单图/多重图

<img src="(数据结构-图).assets/image-20221113145107821.png" alt="image-20221113145107821" style="zoom:67%;" /> 



## 3、概念

### 3.1、度

<img src="(数据结构-图).assets/image-20221113145509792.png" alt="image-20221113145509792" style="zoom:67%;" /> 



### 3.2、顶点-顶点的关系描述

> 强调几个地方
>
> `简单路径`：指的是顶点不重复出现的路径
>
> `点到点的距离`：从顶点u出发，到顶点v的最短路径的距离，若不存在则为无穷
>
> `强连通`：在有向图中，从u到v的路径存在，从v到u的路径存在

<img src="(数据结构-图).assets/image-20221113145848683.png" alt="image-20221113145848683" style="zoom:67%;" /> 





### 3.3、连通图

> **连通图**：
>
> 对于n个顶点的无向图G，
>
> 若G是连通图，则最少有n-1条边
>
> 这个嘛，就拿树来联想吧，除了根节点，每个结点头上都有一条线
>
> 
>
> 若G是非连通图，则最多可能有<img src="(数据结构-图).assets/image-20221113173947690.png" alt="image-20221113173947690" style="zoom:67%;" />
>
> n-1个结点，任意两两配对所形成的边数，能产生的最多的边数，必须除去了一个结点，防止形成连通图
>
> 
>
> **强连通图**：
>
> 若G是强连通图，则最少有n条边
>
> 结合下图理解
>
> <img src="(数据结构-图).assets/image-20221113174443614.png" alt="image-20221113174443614" style="zoom:67%;" /> 
>
> 

<img src="(数据结构-图).assets/image-20221113155354372.png" alt="image-20221113155354372" style="zoom:67%;" /> 





### 3.4、子图

> **生成子图**，包含原图的所有顶点，边集合包含于原边集合

<img src="(数据结构-图).assets/image-20221113155444162.png" alt="image-20221113155444162" style="zoom:67%;" /> 





### 3.5、连通分量/强连通分量

> `无向图`中的`极大连通子图`称为`连通分量`
>
> **极大连通子图**：子图必须连通，且包含尽可能多的顶点和边

<img src="(数据结构-图).assets/image-20221113155750593.png" alt="image-20221113155750593" style="zoom:67%;" /> 



> **强连通分量**

<img src="(数据结构-图).assets/image-20221113160041885.png" alt="image-20221113160041885" style="zoom:67%;" /> 





### 3.6、生成-树/森林

> `连通图`的`生成树`：包含图中`全部顶点`的一个`极小连通子图`(边尽可能地少，但要保持连通)
>
> 若连通图的定点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则不连通；若加上一条边则会形成一个回路

<img src="(数据结构-图).assets/image-20221113161045815.png" alt="image-20221113161045815" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221113162414247.png" alt="image-20221113162414247" style="zoom:67%;" /> 





### 3.7、带权图

<img src="(数据结构-图).assets/image-20221113162524945.png" alt="image-20221113162524945" style="zoom:67%;" /> 





### 3.8、完全图

<img src="(数据结构-图).assets/image-20221113162637886.png" alt="image-20221113162637886" style="zoom:67%;" /> 







### 3.9、稀疏/稠密图

<img src="(数据结构-图).assets/image-20221113162723665.png" alt="image-20221113162723665" style="zoom:67%;" /> 





### 3.10、树

<img src="(数据结构-图).assets/image-20221113163244544.png" alt="image-20221113163244544" style="zoom:67%;" /> 







### 3.11、总结

![image-20221113163313840]((数据结构-图).assets/image-20221113163313840.png)





## 4、邻接矩阵法

<img src="(数据结构-图).assets/image-20221113163803581.png" alt="image-20221113163803581" style="zoom:67%;" /> 





### 4.1、出入度

![image-20221113164047751]((数据结构-图).assets/image-20221113164047751.png)







### 4.2、带权图

<img src="(数据结构-图).assets/image-20221113164241333.png" alt="image-20221113164241333" style="zoom:67%;" /> 





### 4.3、性能分析

<img src="(数据结构-图).assets/image-20221113164411531.png" alt="image-20221113164411531" style="zoom:67%;" /> 





### 4.4、性质

> A^n的元素A^n[i] [j] = 从顶点i到顶点j的长度为n的路径的数目
>
> 例：A^2[1] [4] = 把原矩阵的第一行 * 第四列，得到的值就是第1个顶级到第4个顶点的路径数目的个数

<img src="(数据结构-图).assets/image-20221113173443195.png" alt="image-20221113173443195" style="zoom:67%;" /> 



> A^3[1] [4] = 把A^2[1] [4]的第一行 * 原矩阵的第四列，得到的值就是路径数目的个数	

<img src="(数据结构-图).assets/image-20221113173659851.png" alt="image-20221113173659851" style="zoom:67%;" /> 







### 4.5、总结

<img src="(数据结构-图).assets/image-20221113173728743.png" alt="image-20221113173728743" style="zoom:67%;" /> 





## 5、邻接表法

> *first指向第一条边，而链表的每一个结构体中间存储了指向的下标

<img src="(数据结构-图).assets/image-20221113175538741.png" alt="image-20221113175538741" style="zoom:67%;" /> 



> 如何求顶点的度？入度？出度？
>
> **无向图**：很简单，遍历得到这个结点的链表长度完事了
>
> 
>
> **有向图**：出度，遍历得到该接点的链表长度；但是入度就很麻烦，你要遍历数组全部元素的链表，求出指向指定结点的结点的个数
>
> 

<img src="(数据结构-图).assets/image-20221113175936914.png" alt="image-20221113175936914" style="zoom:67%;" /> 



## 逻辑结构の总结

![image-20221113180522651]((数据结构-图).assets/image-20221113180522651.png)







## 6、图的基础操作

<img src="(数据结构-图).assets/image-20221113225943233.png" alt="image-20221113225943233" style="zoom:67%;" /> 



### 6.1、BFS(广度优先遍历)

#### 6.1.1、代码实现

层次遍历既视感

<img src="(数据结构-图).assets/image-20221114003218841.png" alt="image-20221114003218841" style="zoom:67%;" /> 



> 整挺好，但是忽略了非连通图的情况

<img src="(数据结构-图).assets/image-20221114003645702.png" alt="image-20221114003645702" style="zoom:67%;" /> 

> 补充一下`遍历的可变性`
>
> 同一个图的`邻接矩阵`表示方式唯一，所以最后会是一个递增的结果
>
> <img src="(数据结构-图).assets/image-20221114004021715.png" alt="image-20221114004021715" style="zoom:67%;" /> 
>
> 
>
> 同一个图的`邻接表`表示方式不唯一，BFS得到序列不唯一
>
> <img src="(数据结构-图).assets/image-20221114004143911.png" alt="image-20221114004143911" style="zoom: 50%;" /> 
>
> <img src="(数据结构-图).assets/image-20221114003945698.png" alt="image-20221114003945698" style="zoom:67%;" /> 





> 最终代码实现

<img src="(数据结构-图).assets/image-20221114004552753.png" alt="image-20221114004552753" style="zoom:67%;" /> 





#### 6.1.2、复杂度分析

> **性能分析**
>
> *空间复杂度*
>
> 可能辅助队列的空间复杂度量级最大为O(|V|)
>
> <img src="(数据结构-图).assets/image-20221114005115123.png" alt="image-20221114005115123" style="zoom: 50%;" /> 
>
> 
>
> *时间复杂度*
>
> 主要来自于访问结点和访问边
>
> <img src="(数据结构-图).assets/image-20221114155315658.png" alt="image-20221114155315658" style="zoom:60%;" /> 

 



#### 6.1.3、广度优先生成树

> 说变了就是依靠BFS得到的序列其实是一棵树

<img src="(数据结构-图).assets/image-20221114155856158.png" alt="image-20221114155856158" style="zoom:60%;" /> 





#### 6.1.4、总结

![image-20221114160159985]((数据结构-图).assets/image-20221114160159985.png)







### 6.2、DFS(深度优先遍历)

#### 6.2.1、代码实现

类似于先序遍历

<img src="(数据结构-图).assets/image-20221114161144457.png" alt="image-20221114161144457" style="zoom:67%;" /> 



#### 6.2.2、复杂度分析

<img src="(数据结构-图).assets/image-20221114161551341.png" alt="image-20221114161551341" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221114161655482.png" alt="image-20221114161655482" style="zoom:60%;" />  



> 邻接矩阵表示方式唯一，但是邻接表的表示方式不唯一

<img src="(数据结构-图).assets/image-20221114162237157.png" alt="image-20221114162237157" style="zoom:67%;" /> 



#### 6.2.3、深度优先生成树

> 深度遍历得到的序列其实就是一棵树

<img src="(数据结构-图).assets/image-20221114163006208.png" alt="image-20221114163006208" style="zoom:50%;" /> 

<img src="(数据结构-图).assets/image-20221114163023812.png" alt="image-20221114163023812" style="zoom:50%;" />  不同的邻接表，不同的树



> 非连通图的生成森林

<img src="(数据结构-图).assets/image-20221114163142498.png" alt="image-20221114163142498" style="zoom:50%;" /> 

<img src="(数据结构-图).assets/image-20221114163126924.png" alt="image-20221114163126924" style="zoom:50%;" /> 





> 注意：`调用BFS/DFS的次数 = 连通分量数`

<img src="(数据结构-图).assets/image-20221114162854020.png" alt="image-20221114162854020" style="zoom:67%;" /> 



#### 6.2.4、总结

![image-20221114162945521]((数据结构-图).assets/image-20221114162945521.png)







## 7、图的应用

### 7.1、最小生成树

> 最小生成树的研究对象是：`带权的连通无向图`

<img src="(数据结构-图).assets/image-20221114163620253.png" alt="image-20221114163620253" style="zoom:67%;" />  

<img src="(数据结构-图).assets/image-20221114163629992.png" alt="image-20221114163629992" style="zoom:67%;" /> 









### 7.2、Prim算法/Kruskal算法

<img src="(数据结构-图).assets/image-20221114164000654.png" alt="image-20221114164000654" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221114165445143.png" alt="image-20221114165445143" style="zoom:67%;" /> 



> 两者的比较
>
> <img src="(数据结构-图).assets/image-20221114164441332.png" alt="image-20221114164441332" style="zoom:67%;" /> 





<img src="(数据结构-图).assets/image-20221114164330773.png" alt="image-20221114164330773" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221114165751939.png" alt="image-20221114165751939" style="zoom:67%;" /> 







### 7.3、最短路径问题

<img src="(数据结构-图).assets/image-20221114165948259.png" alt="image-20221114165948259" style="zoom:67%;" /> 



#### 7.3.1、BSF算法(无权图) 

> **实现代码**
>
> 核心在于`广度优先遍历`

<img src="(数据结构-图).assets/image-20221114170758839.png" alt="image-20221114170758839" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221114170938170.png" alt="image-20221114170938170" style="zoom:67%;" /> 





#### 7.3.2、Dijkstra(迪杰斯特拉)算法

> 够复杂的

<img src="(数据结构-图).assets/image-20221114180125609.png" alt="image-20221114180125609" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221114180441719.png" alt="image-20221114180441719" style="zoom:67%;" /> 

 <img src="(数据结构-图).assets/image-20221114180500306.png" alt="image-20221114180500306" style="zoom:60%;" />



> 坑
>
> 迪杰斯特拉算法`不适合带负权值`的图
>
> 下面的例子照这个算法 V0-V2 优于 V0-V1-V2
>
> 但实际上`最好的路径应该是后者`

<img src="(数据结构-图).assets/image-20221114181409585.png" alt="image-20221114181409585" style="zoom:67%;" /> 





#### 7.3.3、Floyd(弗洛伊德)算法

> 动态规划，把问题的求解分为多个阶段

<img src="(数据结构-图).assets/image-20221114201816056.png" alt="image-20221114201816056" style="zoom:67%;" /> 



> 示例：

<img src="(数据结构-图).assets/image-20221114203114985.png" alt="image-20221114203114985" style="zoom:67%;" /> 





<img src="(数据结构-图).assets/image-20221114203045220.png" alt="image-20221114203045220" style="zoom:67%;" /> 



> **核心代码**

<img src="(数据结构-图).assets/image-20221114203637821.png" alt="image-20221114203637821" style="zoom:67%;" />  



> maybe你会问这个时间复杂度O(|V|^3)、空间复杂度O(|V|^2)-二维数组的玩意好像没啥用
>
> 处理个三个结点的，有手就行

> 那么你就错了，请看下面的例子
>
> <img src="(数据结构-图).assets/image-20221114205217230.png" alt="image-20221114205217230" style="zoom: 60%;" /> 
>
> 
>
> 当我允许V1中转的时候，发现了A^(0)[2]-[3] = 2（最短路径）、A^(1)[2]-[4] = 6（最短路径）
>
> <img src="(数据结构-图).assets/image-20221114210426081.png" alt="image-20221114210426081" style="zoom: 67%;" /> A^(1)变成右图所示
>
> *下面就是妙处*
>
> <img src="(数据结构-图).assets/image-20221114210648023.png" alt="image-20221114210648023" style="zoom:67%;" /> 
>
> 如果允许V2中转的时候，出现了3个最短路径
>
> <img src="(数据结构-图).assets/image-20221114210602876.png" alt="image-20221114210602876" style="zoom:77%;" /> 
>
> 但是你发现A^(1)[2]-[3]明明不存在，但实际上由于你的上一步操作，使得A^(1)[2]-[3] = 2了
>
> 相当于V2-V1-V3已经保存下来了，所以后面我们直接利用创造好的条件，V0-V2-(V2-V1-V3) = V0-V3 = 3
>
> 喵哉 
>
>  

> 下面是路径问题

<img src="(数据结构-图).assets/image-20221114205534785.png" alt="image-20221114205534785" style="zoom:67%;" /> 



#### 7.3.4、总结

Floyd算法虽然解决了带负权的有向图的问题，但是带负权回路的图会使其陷入噩梦轮回(bushi

<img src="(数据结构-图).assets/image-20221114205849653.png" alt="image-20221114205849653" style="zoom:67%;" /> 







### 7.4、有向无环图描述表达式

后面再来喵喵喵

<img src="(数据结构-图).assets/image-20221114211228110.png" alt="image-20221114211228110" style="zoom: 50%;" />  



> 下面这玩意可以优化到下一个图
>
> <img src="(数据结构-图).assets/image-20221114211821195.png" alt="image-20221114211821195" style="zoom:67%;" /> 
>
> <img src="(数据结构-图).assets/image-20221114212327196.png" alt="image-20221114212327196" style="zoom: 67%;" />  
>
> <img src="(数据结构-图).assets/image-20221114211859395.png" alt="image-20221114211859395" style="zoom:67%;" /> 
>
> 

 





### 7.5、拓扑排序

<img src="(数据结构-图).assets/image-20221114212954964.png" alt="image-20221114212954964" style="zoom:67%;" />



> 文字一点的定义
>
> 注意，若原图有环，非DAG图的话，是不存在拓扑排序的序列的

<img src="(数据结构-图).assets/image-20221114213528404.png" alt="image-20221114213528404" style="zoom:67%;" />  

> 下面的伪代码，方便理解
>
> ①从AOV网中选择一个`没有前驱(入度为0)`的顶点并输出
>
> ②从AOV网中`删除该顶点和所有以它为起点的有向边`
>
> ③重复①和②直到`当前AOV网为空`或者当前网中不存在无前驱的顶点为止

<img src="(数据结构-图).assets/image-20221114213438492.png" alt="image-20221114213438492" style="zoom:67%;" /> 





> **代码实现**
>
> 竟恐怖如斯

![image-20221114214251082]((数据结构-图).assets/image-20221114214251082.png)

<img src="(数据结构-图).assets/image-20221114214611911.png" alt="image-20221114214611911" style="zoom:67%;" /> 





**逆拓扑排序**

> 整挺好，出度为0的先输出

<img src="(数据结构-图).assets/image-20221114214754597.png" alt="image-20221114214754597" style="zoom:67%;" /> 

<img src="(数据结构-图).assets/image-20221114214821163.png" alt="image-20221114214821163" style="zoom:67%;" /> 



> 利用DFS逆拓扑排序的实现

<img src="(数据结构-图).assets/image-20221114215400850.png" alt="image-20221114215400850" style="zoom:67%;" /> 





### 7.6、总结

<img src="(数据结构-图).assets/image-20221114215504648.png" alt="image-20221114215504648" style="zoom:67%;" /> 











`

`

`

`

`

`