[TOC]





# 一、概念



## 0、绪论

先看下打怪世界的instruction

### 0.1、信息化世界的结构

<img src="(数据结构-线性表).assets/image-20221025161919229.png" alt="image-20221025161919229" style="zoom: 50%;" /> 





### 0.2、数据

<img src="(数据结构-线性表).assets/image-20221025162255799.png" alt="image-20221025162255799" style="zoom:50%;" /> 









### 0.3、结构

<img src="(数据结构-线性表).assets/image-20221025162619087.png" alt="image-20221025162619087" style="zoom:60%;" /> 



<img src="(数据结构-线性表).assets/image-20221025162723836.png" alt="image-20221025162723836" style="zoom:60%;" /> 



<img src="(数据结构-线性表).assets/image-20221025162747565.png" alt="image-20221025162747565" style="zoom:60%;" />  



<img src="(数据结构-线性表).assets/image-20221025162814319.png" alt="image-20221025162814319" style="zoom:60%;" /> 	





<img src="(数据结构-线性表).assets/image-20221025163308352.png" alt="image-20221025163308352" style="zoom:67%;" />  





#### 习题

> `抽象数据类型`描述了`数据的逻辑结构`和`抽象运算`
>
>    如链表		 存储数据的逻辑方式    增删查改
>
> 
>
> 通常由[数据对象，    数据关系，     基本操作集]表示
>
> ​	   如数组    一对一(一对多)    增删查改

<img src="(数据结构-线性表).assets/image-20221025194729792.png" alt="image-20221025194729792" style="zoom:60%;" /> 



> 线性结构的特点是一对一

<img src="(数据结构-线性表).assets/image-20221025195217432.png" alt="image-20221025195217432" style="zoom:60%;" /> 



> ABD都是同时定义了逻辑结构和物理结构的，不可说它是逻辑结构了
>
> 而，有序表仅仅包含了“有序”这个逻辑，所以它属于逻辑结构

<img src="(数据结构-线性表).assets/image-20221025200145595.png" alt="image-20221025200145595" style="zoom:67%;" />  



> 文字题罢了，问题问的是结点内的存储单元地址
>
> 结点之间的内存地址可能不连续，但是结点内部的那几个元素啊，什么ElemType和和*p，这几个玩意肯定是地址连续的啊，而且他们还要内存对齐呢

<img src="(数据结构-线性表).assets/image-20221025200719873.png" alt="image-20221025200719873" style="zoom:67%;" /> 

> 这道题的考点很明晰
>
> 带结构的，我们一下就想到存储结构和逻辑结构
>
> 依次分析，
>
> A：循环队列，用数据表(存储，因为循环表明了它存储的模型)表示的队列(逻辑，先进先出)，它是存储结构和逻辑结构的结合体，所以它与存储结构有关：
>
> B、C：链表、哈希表，都是存储结构啊
>
> D：仅仅是逻辑结构，满足先进后出的逻辑即可
>
> 选D

<img src="(数据结构-线性表).assets/image-20221025205651746.png" alt="image-20221025205651746" style="zoom:60%;" /> 

> 举个例子，我要实现二叉树，那么它有链式存储和顺序存储的两种存储结构
>
> 所以C错了
>
> D错在没有考虑到数据运算
>
> B是错的，存储结构(顺序存储和链式存储)都是依托与，我需要实现的二叉树这个逻辑结构才能出现的，也就是要先有理念，才有实物
>
> A：以面向实际问题(建立一个二叉树)触发，使用抽象的表达方式

<img src="(数据结构-线性表).assets/image-20221025212128864.png" alt="image-20221025212128864" style="zoom:60%;" /> 



> 数据其实等于数据对象和其的数据关系，如果只有对象，而没有关系，那么就是一盘散沙
>
> A：存储数据无需操作存储的方法，存储数据结构(三要素)才要
>
> B：数据元素的类型隐含于数据元素中，很简单啊，计算机底层又不会管你什么int、long，你的数据元素存储多少个字节就是什么类型，所以你的元素已经表明了
>
> 你的数据类型
>
> D：就是操作的一部分，故不需要

<img src="(数据结构-线性表).assets/image-20221025215115975.png" alt="image-20221025215115975" style="zoom:67%;" /> 



> 要知道数据结构包含了三要素：逻辑结构、存储结构和数据运算
>
> 这三者但凡有一个不同，那么就是不同的数据结构
>
> 如二叉树和二叉排序树，逻辑结构和物理结构相同
>
> 但查找结点这个数据运算不同，所以也属于不同的数据结构

<img src="(数据结构-线性表).assets/image-20221025215520079.png" alt="image-20221025215520079" style="zoom:67%;" /> 



> 很简单，栈，数组遍历和链表遍历，效率明显前者更高

<img src="(数据结构-线性表).assets/image-20221025215557489.png" alt="image-20221025215557489" style="zoom:67%;" /> 







### 0.4、算法

<img src="(数据结构-线性表).assets/image-20221025164926756.png" alt="image-20221025164926756" style="zoom:60%;" /> 





### 0.5、算法的时间复杂度

<img src="(数据结构-线性表).assets/image-20221025173718617.png" alt="image-20221025173718617" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221025174343579.png" alt="image-20221025174343579" style="zoom: 50%;" /> 常对幂指阶<img src="(数据结构-线性表).assets/image-20221025174402709.png" alt="image-20221025174402709" style="zoom:50%;" /> <img src="(数据结构-线性表).assets/image-20221025174847433.png" alt="image-20221025174847433" style="zoom:60%;" />



> 例题
>
> <img src="(数据结构-线性表).assets/image-20221025175029748.png" alt="image-20221025175029748" style="zoom:67%;" /> 

<img src="(数据结构-线性表).assets/image-20221025192931989.png" alt="image-20221025192931989" style="zoom:67%;" /> 







### 0.6、算法的空间复杂度

<img src="(数据结构-线性表).assets/image-20221025193357582.png" alt="image-20221025193357582" style="zoom:67%;" /> 



> 例题
>
> <img src="(数据结构-线性表).assets/image-20221025193604780.png" alt="image-20221025193604780" style="zoom:67%;" /> 
>
> <img src="(数据结构-线性表).assets/image-20221025193634927.png" alt="image-20221025193634927" style="zoom:67%;" />  





> 递归感觉8太行
>
> 空间复杂度 = 递归调用的深度
>
> <img src="(数据结构-线性表).assets/image-20221025193948724.png" alt="image-20221025193948724" style="zoom:60%;" />  

<img src="(数据结构-线性表).assets/image-20221025194102147.png" alt="image-20221025194102147" style="zoom:60%;" /> 

​		





## 1.交换两个变量的值

```c
//1、常规方法
void change(char* p1, char* p2)
{
	int tmp = 0;
	tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}


//利用加法
void change(char* p1, char* p2)
{
    //牛的
	*p1 = *p1 + *p2;
	*p2 = *p1 - *p2;
	*p1 = *p1 - *p2;
}


//利用异或(^)
void change(char* p1, char* p2)
{
    
	*p1 = *p1 ^ *p2;
	*p2 = *p1 ^ *p2;
	*p1 = *p1 ^ *p2;
}

//第四个，牛逼，要底层汇编可能才能彻底看懂吧
//跟具体编译器类型有关，不一定有效。例如在VS的Windows编译器、GDB都不行。
b = (a + b) - (a = b);
```

> 1. 归零律：a⊕a=0 （每一位相加，忽略进位的结果肯定为0）
>
> 2. 恒等律：a⊕0=a  （每一位和0相加还是它本身）
>
> 3. 交换律： a⊕b=b⊕a    
>
> 4. 结合律：a⊕b⊕c=（a⊕b）⊕c=a⊕（b⊕c）
>
> 5. `自反：a⊕b⊕b=a⊕（b⊕b）=a⊕0=a（由上面推导得出）`
>
>    **第五条结论很重要，请先完全搞明白**
>
> 面试中经常问到如何不使用第三个变量交换两个数的值？
>
> 答案是
>
> a = a ^ b;
> b = a ^ b;
> a = a ^ b;
> 很多人不知道为什么   接下来就推导下
>
> 假设 刚开始 a=x  ， b=y。
>
> 第一次异或运算 `a= a^b = x^y`，b还等于y
> 第二次异或运算 b= `a^b = x^y^y = x^0 =x` ，此时b的值变为x
> 第三次异或运算 a= a^b = x^y^x = y^0 = y，此时a的值变为y
> 至此完成了交换过程。当然使用该方法进行变量交换时需要注意一点，a、b对应的内存区域一定不可以是同一块，因为如果是一块区域异或操作会把这块内存的数值改成0。（数组中的交换位置需要特别注意）





## 2、时间复杂度

当两个核心代码段都有各自的复杂度时，计算总的复杂度应该遵循以下原则

(1)如果是并行的两段代码，则取**复杂度最大**的代码段为总的复杂度

(2)如果是有for循环等循环、嵌套操作时，即采取**复杂度相乘**作为总的复杂	度	

![image-20220902151646338]((数据结构-线性表).assets/image-20220902151646338.png) 

![image-20220902152041271]((数据结构-线性表).assets/image-20220902152041271.png)

![image-20220902154155123]((数据结构-线性表).assets/image-20220902154155123.png)

![image-20220902154258467]((数据结构-线性表).assets/image-20220902154258467.png)



​	



## 3、结构体

### 3.1、结构体指针作为函数参数

结构体变量名代表的是整个集合本身，作为函数参数时**传递的整个集合**，也就是所有成员，而不是像数组一样被编译器转换成一个指针。

如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运行效率。

所以最好的办法就是使用结构体指针，这时由实参传向形参的只是一个地址，非常快速。



### 3.2、结构体内存对齐





### 3.3、typedef的使用

typedef可以对数组、指针、结构体、函数起别名

```c
//关于typedef我的理解就是从新名字解码(解封)，得到左边的数据类型，来判断右边新名字的含义
//当然自定义的话还是得根据需求好好想一想

//对数组起别名
//解析一下，右边ARRAY[20]等价于左边的char，就说明ARRAY这个新的数据类型 代表了一个长度为20的字符数组
//ARRAY a 等价于 char a[20];
typedef char ARRAY[20];

//给结构体起别名
//Struct Student stu 等价于 STU stu;
typedef struct Student{
  char name[20];  
}STU;

//给指针起别名
//从右边解码，由于括号，先*PTR_TO_ARR后[4]，得到左边的int
//于是看出PTR_TO_ARR这个数据类型，封装了一个指向int [4]数组的指针
//PTR_TO_ARR ptr 等价于 int (*a)[4];  
typedef int (*PTR_TO_ARR)[4];

//给函数起别名
//等价于 我们知道，单独的int (*p)(int,int)，p代表定义了一个函数指针(其返回值为int，两个int形参数)，
typedef int (*PTR_TO_FUNC)(int, int);
PTR_TO_FUNC pfunc;
```



## 4、内存结构

| 内存区域 | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| 栈区     | 存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方式类似于数据结构中的栈 |
| 堆区     | 就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释放。分配方式类似于数据结构中的链表。“内存泄漏”通常说的就是堆区。 |
| 静态区   | 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后，由系统释放。 |
| 常量区   | 常量存储在这里，不允许修改。                                 |
| 代码区   | 顾名思义，存放代码                                           |

> 1.void *malloc(unsigned int size)：作用是在动态存储区中分配一个长度为size的连续空间，unsigned代表没有符号位的整形数据(非负整数)，返回所分配内存区域第一个字节的地址.分配失败返回NULL指针
>
> 2.void *calloc(unsigned n,unsigned size)：作用是在动态内存空间中分配n个长度为size的连续空间，分配失败返回NULL指针
>
> 3.void free(void *p)：释放指针变量p所指向的动态空间
>
> 4.void *realloc(void *p,unsigned int size):对已经通过malloc函数calloc函数获得了动态空间，想改变其大小，用此函数重新分配

> 注意：**void\*类型的指针表示指向空类型或者不指向确定的类型的数据**
>
> 以上函数得使用`#include<stdlib.h>`









# 二、线性表

## 1、定义

<img src="(数据结构-线性表).assets/image-20221028112919375.png" alt="image-20221028112919375" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221028113308706.png" alt="image-20221028113308706" style="zoom:60%;" />  

<img src="(数据结构-线性表).assets/image-20221028113814712.png" alt="image-20221028113814712" style="zoom:60%;" />  

<img src="(数据结构-线性表).assets/image-20221028114221938.png" alt="image-20221028114221938" style="zoom: 50%;" /> 

> 总结
>
> <img src="(数据结构-线性表).assets/image-20221028114317505.png" alt="image-20221028114317505" style="zoom:60%;" /> 
>
> <img src="(数据结构-线性表).assets/image-20221028114400442.png" alt="image-20221028114400442" style="zoom:50%;" /> 







## 2、顺序表(顺序存储)

> 顺序表：`逻辑上相邻`的元素存储在`物理位置也相邻`

<img src="(数据结构-线性表).assets/image-20221028114740263.png" alt="image-20221028114740263" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221028120009442.png" alt="image-20221028120009442" style="zoom:60%;" /> 





### 2.1、静态/动态分配

> 可能出现内存浪费

<img src="(数据结构-线性表).assets/image-20221028115739406.png" alt="image-20221028115739406" style="zoom: 60%;" />  

> 大小可变的顺序表	

<img src="(数据结构-线性表).assets/image-20221028115646280.png" alt="image-20221028115646280" style="zoom:67%;" /> 

<img src="(数据结构-线性表).assets/image-20221028121707363.png" alt="image-20221028121707363" style="zoom: 60%;" /> 

 



### 2.2、特点

<img src="(数据结构-线性表).assets/image-20221028121904012.png" alt="image-20221028121904012" style="zoom:60%;" /> 



### 2.3、插入/删除/查找

<img src="(数据结构-线性表).assets/image-20221028162240839.png" alt="image-20221028162240839" style="zoom:60%;" />  

<img src="(数据结构-线性表).assets/image-20221028163450961.png" alt="image-20221028163450961" style="zoom:60%;" />  



> 按位查找

<img src="(数据结构-线性表).assets/image-20221029011717602.png" alt="image-20221029011717602" style="zoom:67%;" /> 



> 按值查找

<img src="(数据结构-线性表).assets/image-20221029011112904.png" alt="image-20221029011112904" style="zoom:67%;" /> 



### 2.4、总结

<img src="(数据结构-线性表).assets/image-20221028121933776.png" alt="image-20221028121933776" style="zoom:67%;" />

<img src="(数据结构-线性表).assets/image-20221028163538707.png" alt="image-20221028163538707" style="zoom:60%;" /> 



## 3、链表(链式存储)

> 逻辑上相邻，但物理位置不相邻

<img src="(数据结构-线性表).assets/image-20221029015325832.png" alt="image-20221029015325832" style="zoom:60%;" /> 





### 单链表

### 3.1、初始化/判空/创建

> 不带头结点

<img src="(数据结构-线性表).assets/image-20221029020055019.png" alt="image-20221029020055019" style="zoom:60%;" /> 

> 带头结点

<img src="(数据结构-线性表).assets/image-20221029020138245.png" alt="image-20221029020138245" style="zoom:60%;" /> 



> 尾插法建立单链表

<img src="(数据结构-线性表).assets/image-20221031201747428.png" alt="image-20221031201747428" style="zoom:67%;" /> 

> 头插法建立单链表

<img src="(数据结构-线性表).assets/image-20221031202746986.png" alt="image-20221031202746986" style="zoom:60%;" />  









### 3.2、插入/删除

> 按位序插入，带头结点

<img src="(数据结构-线性表).assets/image-20221029171734689.png" alt="image-20221029171734689" style="zoom:60%;" /> 	 

> 不带头结点插入

![image-20221030005407899]((数据结构-线性表).assets/image-20221030005407899.png)

> 指定结点的前插

<img src="(数据结构-线性表).assets/image-20221030014012936.png" alt="image-20221030014012936" style="zoom:67%;" /> 

> 尾插法

<img src="(数据结构-线性表).assets/image-20221030014040842.png" alt="image-20221030014040842" style="zoom:67%;" /> 





> 删除，不带头结点

<img src="(数据结构-线性表).assets/image-20221030014132082.png" alt="image-20221030014132082" style="zoom:60%;" /> 

> 指定节点的删除 

<img src="(数据结构-线性表).assets/image-20221030014847228.png" alt="image-20221030014847228" style="zoom:60%;" /> 











<img src="(数据结构-线性表).assets/image-20221029020248521.png" alt="image-20221029020248521" style="zoom:60%;" /> 



### 3.3、查找

> 按位查找

<img src="(数据结构-线性表).assets/image-20221031181555903.png" alt="image-20221031181555903" style="zoom:60%;" /> 

> 按值查找

<img src="(数据结构-线性表).assets/image-20221031184129782.png" style="zoom:67%;" /> 	

 

> 求长度

<img src="(数据结构-线性表).assets/image-20221031184325265.png" alt="image-20221031184325265" style="zoom:67%;" /> 





### 双链表

### 3.1、初始化/判空

<img src="(数据结构-线性表).assets/image-20221031214738150.png" alt="image-20221031214738150" style="zoom:60%;" /> 



### 3.2、插入/删除

> 插入

<img src="(数据结构-线性表).assets/image-20221031220025646.png" alt="image-20221031220025646" style="zoom:60%;" /> 



> 删除

<img src="(数据结构-线性表).assets/image-20221031223123020.png" alt="image-20221031223123020" style="zoom:60%;" /> 



### 3.3、遍历	

<img src="(数据结构-线性表).assets/image-20221031223327512.png" alt="image-20221031223327512" style="zoom:60%;" /> 





### 循环链表

3.1、初始化/判空/判尾

> 就普通的单链表特殊处理一下尾结点就好了

<img src="(数据结构-线性表).assets/image-20221101114206337.png" alt="image-20221101114206337" style="zoom:60%;" /> 

> 循环双链表

<img src="(数据结构-线性表).assets/image-20221101114937594.png" alt="image-20221101114937594" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101115015891.png" alt="image-20221101115015891" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101115053434.png" alt="image-20221101115053434" style="zoom:60%;" /> 



### 静态链表

用数组的方式实现链表

> 分配了`一整片连续`的内存空间，各个结点集中安置
>
> 每个`数据元素4个字节`，`游标4个字节`(结点共8个字节)
>
> `数据元素`存放`不同的结点`，`游标`存放它的`下一个结点所在的下标`
>
> addr为头结点的地址，通过游标好似把结点用指针连接起来一样

> 注意：
>
> <img src="(数据结构-线性表).assets/image-20221101171039163.png" alt="image-20221101171039163" style="zoom:67%;" /> 这个typedef的用法就相当于封装了SLinkList为一个**长度为10**，**元素类型为当前结构体**的数据类型

<img src="(数据结构-线性表).assets/image-20221101141430077.png" alt="image-20221101141430077" style="zoom:60%;" /> 



<img src="(数据结构-线性表).assets/image-20221101142928346.png" alt="image-20221101142928346" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101143053160.png" alt="image-20221101143053160" style="zoom:60%;" />  





## 4、顺序表和链表的区别

> 存储结构上的区别

<img src="(数据结构-线性表).assets/image-20221101143306869.png" alt="image-20221101143306869" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101143839968.png" alt="image-20221101143839968" style="zoom:60%;" /> 



<img src="(数据结构-线性表).assets/image-20221101145036130.png" alt="image-20221101145036130" style="zoom:60%;" /> 



<img src="(数据结构-线性表).assets/image-20221101145157505.png" alt="image-20221101145157505" style="zoom:60%;" /> 



<img src="(数据结构-线性表).assets/image-20221101145313267.png" alt="image-20221101145313267" style="zoom:67%;" /> 





<img src="(数据结构-线性表).assets/image-20221101145412681.png" alt="image-20221101145412681" style="zoom:60%;" /> 







## 5、栈

### 5.1、定义

> 其实也是线性表的一对一
>
> 但是插入操作有限制：`只能在一端插入和删除，不能在中间插入删除`

<img src="(数据结构-线性表).assets/image-20221101145837381.png" alt="image-20221101145837381" style="zoom:60%;" />  

> 栈顶：允许插入删除的一端
>
> 栈底：不允许的一端

<img src="(数据结构-线性表).assets/image-20221101150138116.png" alt="image-20221101150138116" style="zoom:67%;" /> 





### 5.2、顺序/链栈操作

<img src="(数据结构-线性表).assets/image-20221101150334853.png" alt="image-20221101150334853" style="zoom:60%;" /> 



#### 5.2.1、初始化

<img src="(数据结构-线性表).assets/image-20221101153413269.png" alt="image-20221101153413269" style="zoom:60%;" /> 



> 链栈的初始化就是建立一个普通的链表

<img src="(数据结构-线性表).assets/image-20221101162711191.png" alt="image-20221101162711191" style="zoom:67%;" /> 



#### 5.2.3、入栈/出栈

> 顺序栈

<img src="(数据结构-线性表).assets/image-20221101161138858.png" alt="image-20221101161138858" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101161345242.png" alt="image-20221101161345242" style="zoom:60%;" /> 

> 上面的栈顶指针top是指向当前元素
>
> 下面的top是指向下一个可以插入的位置
>
> 需要注意的是，当top = MAXSIZE的时候，就已经栈满了，数组起始位下标为0，不能插入到MAXSIZE的位置

<img src="(数据结构-线性表).assets/image-20221101161537691.png" alt="image-20221101161537691" style="zoom:60%;" /> 



> 链栈的入栈、出栈
>
> 入栈就是使用头插法，插入结点，出栈就是把头插法反过来，删除元素

<img src="(数据结构-线性表).assets/image-20221101162940811.png" alt="image-20221101162940811" style="zoom:67%;" /> 

<img src="(数据结构-线性表).assets/image-20221101162918842.png" alt="image-20221101162918842" style="zoom:67%;" /> 





#### 5.2.4、总结

> 注意：销毁顺序栈会自动进行，函数运行结束系统就会自动回收内存

<img src="(数据结构-线性表).assets/image-20221101161935722.png" alt="image-20221101161935722" style="zoom:60%;" /> 





### 5.3、栈的应用

#### 5.3.1、括号匹配问题

<img src="(数据结构-线性表).assets/image-20221103172024868.png" alt="image-20221103172024868" style="zoom:60%;" /> 



#### 5.3.2、递归

斐波拉契是也







## 6、队列

### 6.1、定义

FIFO

<img src="(数据结构-线性表).assets/image-20221101195537434.png" alt="image-20221101195537434" style="zoom:67%;" /> 





### 6.2、顺序实现

#### 6.2.1、初始化

<img src="(数据结构-线性表).assets/image-20221101195740852.png" alt="image-20221101195740852" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101200237322.png" alt="image-20221101200237322" style="zoom:60%;" /> 



#### 6.2.2、入队/出队

<img src="(数据结构-线性表).assets/image-20221101200143497.png" alt="image-20221101200143497" style="zoom:60%;" /> 



> 循环队列
>
> 最关键的地方在于 Q.rear = (Q.rear + 1) % MAXSIZE
>
> 使其逻辑上成为了一个闭环队列

<img src="(数据结构-线性表).assets/image-20221101200534656.png" alt="image-20221101200534656" style="zoom:60%;" /> 

> 出队和查找

<img src="(数据结构-线性表).assets/image-20221101200654156.png" alt="image-20221101200654156" style="zoom:60%;" /> 

 



#### 6.2.3、判空/判满/获取元素个数

**获取元素个数**

> `获取队列中元素的个数，判断是否达到最大值` ——> 此处最大值可能是MAXSIZE或者MAXSIZE-1，看rear指向元素不
>
> `元素个数：(rear + MAXSIZE-front) % MAXSIZE`
>
> 解释：
>
> ①当rear在front后面的时候，就相当于rear-front了，把MAXSIZE模运算掉了
>
> ②当rear在front前面的时候，其实%MAXSIZE没啥用了，
>
> rear代表在它前面的元素个数
>
> MAXSIZE-front，相当于减去了为空的元素个数，即在front后面的那些元素的个数
>
> <img src="(数据结构-线性表).assets/image-20221101230051226.png" alt="image-20221101230051226" style="zoom:50%;" /> 



**判空判满的3个方案**

> 方案一：`若队尾指针的下一个结点是队头指针，则为满；若队尾指针等于队头指针，则为空`	——> 牺牲一个存储单元
>
> (Q.rear+1)%MAXSIZE == Q.front; // 满
>
> Q.front == Q.rear; // 空

<img src="(数据结构-线性表).assets/image-20221101201534187.png" alt="image-20221101201534187" style="zoom:60%;" /> 

> 方案二：`加一个size域，当入队就加1，出队就减1`
>
> 通过最后的size大小判断已满/已空
>
> size域的存在可以不浪费那个存储空间

<img src="(数据结构-线性表).assets/image-20221101201909201.png" alt="image-20221101201909201" style="zoom:60%;" /> 

> 方案三：`加一个tag域，当删除成功，令tag=0；当插入成功，令tag=1`
>
> 队满的时候，必然发生了插入，则tag=1	——> (front == rear) && tag == 1
>
> 队空的时候，必然发生了删除或者初始化为空，此时tag=0	——> (front == rear) && tag == 0
>
> **注意**：tag域的存在，可以不浪费那个存储空间

<img src="(数据结构-线性表).assets/image-20221101202008872.png" alt="image-20221101202008872" style="zoom:60%;" /> 





#### 6.2.4、rear指向队尾元素

> 问题不大
>
> 入队的时候，先让rear后移一位，再让元素插入
>
> 出队的时候，先让元素出队，再把front后移一位

<img src="(数据结构-线性表).assets/image-20221101202423545.png" alt="image-20221101202423545" style="zoom:60%;" /> 

> `初始化方式`
>
> rear初始的时候要指向数组末尾
>
> 这样才能让rear+1，使得第0号元素被赋值，成为队尾元素
>
> <img src="(数据结构-线性表).assets/image-20221101231316576.png" alt="image-20221101231316576" style="zoom:67%;" /> 
>
> `判空`：即当上图的情形出现即为空，（rear+1%MAXSIZE == front的时候即为空
>
> 
>
> `判满`：
>
> 由于防止与判空矛盾(当rear在front前面一个位置的时候，即为空)，那么当rear在front`前两个位置`的时候，即为满	——> 牺牲一个存储单元
>
> 也可以采用另外两种方案	 

<img src="(数据结构-线性表).assets/image-20221101202353824.png" alt="image-20221101202353824" style="zoom:60%;" /> 





#### 6.2.5、总结

<img src="(数据结构-线性表).assets/image-20221101202530801.png" alt="image-20221101202530801" style="zoom:60%;" /> 









### 6.3、链式存储

#### 6.3.1、初始化

<img src="(数据结构-线性表).assets/image-20221101202740408.png" alt="image-20221101202740408" style="zoom:60%;" /> 

> 初始化

<img src="(数据结构-线性表).assets/image-20221101202912033.png" alt="image-20221101202912033" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101202826767.png" alt="image-20221101202826767" style="zoom:60%;" /> 





#### 6.3.2、入队/出队



<img src="(数据结构-线性表).assets/image-20221101204659023.png" alt="image-20221101204659023" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101204718501.png" alt="image-20221101204718501" style="zoom:60%;" /> 



> 出队

<img src="(数据结构-线性表).assets/image-20221101204907226.png" alt="image-20221101204907226" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221101205020603.png" alt="image-20221101205020603" style="zoom:60%;" /> 



#### 6.3.3、判满

> 链式队列一般不会满的

<img src="(数据结构-线性表).assets/image-20221101205059030.png" alt="image-20221101205059030" style="zoom:50%;" /> 





#### 6.3.4、总结

<img src="(数据结构-线性表).assets/image-20221101205248308.png" alt="image-20221101205248308" style="zoom: 50%;" /> 







### 6.4、双端队列

<img src="(数据结构-线性表).assets/image-20221103165409209.png" alt="image-20221103165409209" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221103165717375.png" alt="image-20221103165717375" style="zoom:60%;" /> 



> **输出受限的双端队列**
>
> 有一个小技巧，假设你看到了3输出，那么必然输入了1,2
>
> 此时你根据后面1,2先后，判断1,2分别在那端插入
>
> 3,1,2	——> 左插入1，右插入2
>
> 3,2,1	——> 左边插入1，左插入2

<img src="(数据结构-线性表).assets/image-20221103171035909.png" alt="image-20221103171035909" style="zoom:50%;" /> 

> **输入受限的双端队列**
>
> 

<img src="(数据结构-线性表).assets/image-20221103171120007.png" alt="image-20221103171120007" style="zoom:50%;" /> 





### 6.5、队列的应用

#### 6.5.1、树的层次遍历

> *此处只有概念*
>
> 开始从根结点处理
>
> 1	有左右孩子	入队变为1 -> 2 ——> 3	1处理完出队
>
> 2 ——> 3	2有左右孩子 入队2 ——> 3 ——> 4 ——> 5	2处理完出队
>
> 3 ——> 4 ——> 5 ...

<img src="(数据结构-线性表).assets/image-20221103200614201.png" alt="image-20221103200614201" style="zoom:60%;" /> 



#### 6.5.2、图的广度优先遍历

> 1	1相邻结点为2、3	入队1-2-3	1处理完出队
>
> 2-3	2相邻结点4	入队2-3-4	2处理完出队
>
> 3-4	...

<img src="(数据结构-线性表).assets/image-20221103201108788.png" alt="image-20221103201108788" style="zoom:60%;" /> 





#### 6.5.3、先来先服务

<img src="(数据结构-线性表).assets/image-20221103201514133.png" alt="image-20221103201514133" style="zoom:60%;" /> 





## 7、矩阵

### 7.1、概述

<img src="(数据结构-线性表).assets/image-20221103201800668.png" alt="image-20221103201800668" style="zoom:50%;" /> 



> **行优先**
>
> 在二维数组b[M] [N]中
>
> ```c
> b[i][j] = LOC + (i * N + j) * sizeof(ElemType);
> ```
>
> 

<img src="(数据结构-线性表).assets/image-20221103202111300.png" alt="image-20221103202111300" style="zoom:60%;" /> 

> **列优先存储**
>
> 在二维数组b[M] [N]中
>
> ```c
> b[i][j] = LOC + (j * M + i) * sizeof(ElemType);
> ```
>
> 注意看下面的存储顺序，淦，真的怪
>
> 

<img src="(数据结构-线性表).assets/image-20221103202405029.png" alt="image-20221103202405029" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221103203703029.png" alt="image-20221103203703029" style="zoom:60%;" /> 	





### 7.2、对称矩阵

> 这里突出如何压缩存储这大家伙

<img src="(数据结构-线性表).assets/image-20221103204948877.png" alt="image-20221103204948877" style="zoom:60%;" /> 

> **如果取下三角区**
>
> <img src="(数据结构-线性表).assets/image-20221103205832133.png" alt="image-20221103205832133" style="zoom:70%;" /> 
>
> 
>
> `a[i] [j]是第几个元素呢？`
>
> <img src="(数据结构-线性表).assets/image-20221103205636632.png" alt="image-20221103205636632" style="zoom: 67%;" /> a(3,2) 其实是前面个元素个数加列数
>
> 前面的元素 = (i-1)*i/2
>
> 列数 = j（但实际上要减1）
>
> 那么<img src="(数据结构-线性表).assets/image-20221103205756538.png" alt="image-20221103205756538" style="zoom: 80%;" /> `要减1，因为在数组里面`

> `如果求整个矩阵呢？`
>
>  众所周知，`i >= j时`，矩阵是`下半区`
>
> ​		 i < j时，矩阵是上半区
>
> ​		 a(i, j) = a(j, i)
>
> 假设上半区的求元素公式：f(x, y)
>
> 
>
> *当我求a(i, j)(此时i<j，即位于上半区)时*
>
> ∵ a(i, j) = a(j, i)
>
> ∴ 取个反，变成求a(j, i)
>
> 这样就可以带入求上半区的公式：f(j, i)
>
> <img src="(数据结构-线性表).assets/image-20221103211746001.png" alt="image-20221103211746001" style="zoom:67%;" /> 
>
> 

<img src="(数据结构-线性表).assets/image-20221103210621410.png" alt="image-20221103210621410" style="zoom:60%;" /> 

> **列优先压缩存储**

<img src="(数据结构-线性表).assets/image-20221103213053462.png" alt="image-20221103213053462" style="zoom:60%;" /> 







### 7.3、上/下三角矩阵

> 举例，上三角矩阵指除了上三角和对角线外，其他元素都相同，假设为c
>
> 那么就把c的值存储到n(n+1)/2

<img src="(数据结构-线性表).assets/image-20221104084322222.png" alt="image-20221104084322222" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221104085114587.png" alt="image-20221104085114587" style="zoom:60%;" /> 



### 7.4、三对角矩阵

<img src="(数据结构-线性表).assets/image-20221104091120751.png" alt="image-20221104091120751" style="zoom:60%;" /> 

> 这里的 i>= [(k+2)/3]，理解为刚好取整，得到那一行

<img src="(数据结构-线性表).assets/image-20221104092452266.png" alt="image-20221104092452266" style="zoom:60%;" /> 



### 7.5、稀疏矩阵

> 稀疏矩阵：非零元素的个数远远少于矩阵元素个数

<img src="(数据结构-线性表).assets/image-20221104093411066.png" alt="image-20221104093411066" style="zoom:60%;" /> 

> 上面是第一种压缩方法，下面是第二种

<img src="(数据结构-线性表).assets/image-20221104093837648.png" alt="image-20221104093837648" style="zoom:60%;" /> 



### 7.6、总结

<img src="(数据结构-线性表).assets/image-20221104093909902.png" alt="image-20221104093909902" style="zoom:60%;" /> 

<img src="(数据结构-线性表).assets/image-20221104093931333.png" alt="image-20221104093931333" style="zoom:60%;" /> 











## 8、广义表

### 8.1、概述

<img src="(数据结构-线性表).assets/image-20221116171101078.png" alt="image-20221116171101078" style="zoom:67%;" /> 

<img src="(数据结构-线性表).assets/image-20221116172421994.png" alt="image-20221116172421994" style="zoom:67%;" /> 





> 示例：
>
> <img src="(数据结构-线性表).assets/image-20221116172341958.png" alt="image-20221116172341958" style="zoom:50%;" /> 





### 8.2、性质 

<img src="(数据结构-线性表).assets/image-20221116172947354.png" alt="image-20221116172947354" style="zoom:67%;" /> 

<img src="(数据结构-线性表).assets/image-20221116173312789.png" alt="image-20221116173312789" style="zoom:67%;" /> 



> 广义表可以看成线性表的推广
>
> ​	二维数组每行或每列可以看做子表处理，二维数组就是一个广义表

<img src="(数据结构-线性表).assets/image-20221116173428969.png" alt="image-20221116173428969" style="zoom:67%;" /> 







### 8.3、运算

<img src="(数据结构-线性表).assets/image-20221116174054932.png" alt="image-20221116174054932" style="zoom:67%;" /> 





















`

`

`

`





